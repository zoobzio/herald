---
title: Core Concepts
description: Understanding Providers, Publishers, Subscribers, and Messages in herald.
author: Herald Team
published: 2025-12-06
tags: [Concepts, Architecture, Learning]
---

# Core Concepts

## The Broker Bridge Model

Herald organizes broker integration around five core concepts:

1. **Providers** - Broker implementations (Kafka, SQS, NATS, etc.)
2. **Publishers** - Observe capitan signals, forward to brokers
3. **Subscribers** - Consume from brokers, emit to capitan
4. **Messages** - Data with acknowledgment controls
5. **Codecs** - Serialization format (JSON by default, pluggable)

```
┌──────────────────────────────────────────────────────────────────┐
│                        Event Flow                                 │
└──────────────────────────────────────────────────────────────────┘

                    PUBLISH DIRECTION
                    ─────────────────
Application Code
      │
      ▼
  capitan.Emit(ctx, signal, fields...)
      │
      ▼
┌─────────────┐
│  Publisher  │ (observes signal via capitan.Hook)
│             │
│  ┌───────┐  │
│  │ pipz  │  │ (timeout, retry, rate limit)
│  └───────┘  │
└─────────────┘
      │
      ▼
┌─────────────┐
│  Provider   │ (kafka, sqs, nats, etc.)
│  .Publish() │
└─────────────┘
      │
      ▼
┌─────────────┐
│   Broker    │
└─────────────┘


                   SUBSCRIBE DIRECTION
                   ───────────────────
┌─────────────┐
│   Broker    │
└─────────────┘
      │
      ▼
┌─────────────┐
│  Provider   │
│ .Subscribe()│ (returns <-chan Result[Message])
└─────────────┘
      │
      ▼
┌─────────────┐
│ Subscriber  │
│             │
│  ┌───────┐  │
│  │ pipz  │  │ (timeout, retry, rate limit)
│  └───────┘  │
│             │
│  ┌───────┐  │
│  │ Codec │  │ (unmarshal to T)
│  │Decode │  │
│  └───────┘  │
│             │
│  ┌───────┐  │
│  │capitan│  │ (emit to signal)
│  │ .Emit │  │
│  └───────┘  │
│             │
│  Ack/Nack   │ (based on pipeline success/failure)
└─────────────┘
      │
      ▼
  capitan.Hook(signal, handler)
      │
      ▼
Application Code
```

## Providers

A **Provider** abstracts a message broker. It handles connection, serialization format mapping, and broker-specific semantics.

### The Provider Interface

```go
type Provider interface {
    // Publish sends raw bytes with metadata to the broker.
    Publish(ctx context.Context, data []byte, metadata Metadata) error

    // Subscribe returns a stream of messages from the broker.
    Subscribe(ctx context.Context) <-chan Result[Message]

    // Close releases broker resources.
    Close() error
}
```

### Creating Providers

Each provider has its own constructor with interface-based options. Providers define interfaces rather than depending on vendor types directly, allowing testability and flexibility:

```go
// Kafka - pass a kafka-go Writer/Reader
kafkaProvider := kafka.New("orders-topic",
    kafka.WithWriter(kafkaWriter),  // *kafka.Writer
    kafka.WithReader(kafkaReader),  // *kafka.Reader
)

// AWS SQS - pass a client implementing the SQS interface
sqsProvider := sqs.New("https://sqs.us-east-1.amazonaws.com/123456789/orders",
    sqs.WithClient(sqsClient),
)

// NATS - pass connection and subscriber interfaces
natsProvider := nats.New("orders",
    nats.WithConn(natsConn),
    nats.WithSubscriber(natsSub),
)

// Redis Streams - pass a client implementing the Redis interface
redisProvider := redis.New("orders-stream",
    redis.WithClient(redisClient),
    redis.WithGroup("order-group"),
)

// BoltDB (embedded) - pass a DB interface
boltProvider := bolt.New("orders",
    bolt.WithDB(boltDB),
)
```

### Provider Lifecycle

```go
// Create provider
provider := kafka.New("topic", kafka.WithWriter(writer))

// Use provider with publishers/subscribers
pub := herald.NewPublisher(provider, signal, key, nil)
pub.Start(ctx)

// ... application runs ...

// Cleanup
pub.Close()
provider.Close() // Release broker connections
```

### Available Providers

| Provider | Package | Import |
|----------|---------|--------|
| Kafka | `herald/kafka` | `github.com/zoobzio/herald/kafka` |
| NATS | `herald/nats` | `github.com/zoobzio/herald/nats` |
| Google Pub/Sub | `herald/pubsub` | `github.com/zoobzio/herald/pubsub` |
| Redis Streams | `herald/redis` | `github.com/zoobzio/herald/redis` |
| AWS SQS | `herald/sqs` | `github.com/zoobzio/herald/sqs` |
| RabbitMQ/AMQP | `herald/amqp` | `github.com/zoobzio/herald/amqp` |
| AWS SNS | `herald/sns` | `github.com/zoobzio/herald/sns` |
| SQL | `herald/sql` | `github.com/zoobzio/herald/sql` |
| BoltDB | `herald/bolt` | `github.com/zoobzio/herald/bolt` |
| Firestore | `herald/firestore` | `github.com/zoobzio/herald/firestore` |
| io | `herald/io` | `github.com/zoobzio/herald/io` |

## Publishers

A **Publisher** observes a capitan signal and forwards matching events to a broker.

### Creating Publishers

```go
// Define signal and key
orderCreated := capitan.NewSignal("order.created", "Order created")
orderKey := capitan.NewKey[Order]("order", "app.Order")

// Create publisher
pub := herald.NewPublisher(provider, orderCreated, orderKey, nil)

// Start observing (hooks into capitan)
pub.Start(ctx)

// Now any emission to orderCreated gets published
capitan.Emit(ctx, orderCreated, orderKey.Field(Order{ID: "123"}))
```

### Publisher Lifecycle

```
┌───────────────────────────────────────────────────────┐
│                   Publisher Lifecycle                  │
└───────────────────────────────────────────────────────┘

NewPublisher()          Start(ctx)              Close()
     │                      │                      │
     ▼                      ▼                      ▼
┌─────────┐           ┌─────────┐           ┌─────────┐
│ Created │──────────►│ Running │──────────►│ Stopped │
│         │           │         │           │         │
│ - No    │           │ - Hooks │           │ - Hook  │
│   hooks │           │   into  │           │   closed│
│         │           │ capitan │           │         │
└─────────┘           └─────────┘           └─────────┘
```

### How Publishing Works

1. Publisher hooks into capitan for the specified signal
2. When an event is emitted, the hook fires
3. Publisher extracts the typed value from the event
4. Value is marshaled to bytes using the codec (JSON by default)
5. Bytes are passed through the pipeline (timeout, retry, etc.)
6. Provider.Publish() sends to the broker

```go
// Internal flow (simplified)
capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    value, ok := key.From(e)      // Extract typed value
    if !ok {
        return                     // Wrong type, ignore
    }

    data, err := codec.Marshal(value)  // Serialize using codec
    if err != nil {
        return
    }

    metadata := MetadataFromContext(ctx)  // Get headers
    metadata["Content-Type"] = codec.ContentType()  // Add content type

    // Run through pipeline (timeout, retry, etc.)
    pipeline.Process(ctx, value)

    // Terminal operation: publish to broker
    provider.Publish(ctx, data, metadata)
})
```

### Publisher Options

```go
// Pipeline options wrap the publish operation
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithBackoff[Order](3, 100*time.Millisecond),
    herald.WithRateLimit[Order](100, 10),
}

pub := herald.NewPublisher(provider, signal, key, opts)

// Custom capitan instance (instead of default singleton)
pub := herald.NewPublisher(provider, signal, key, opts,
    herald.WithPublisherCapitan[Order](customCapitan),
)

// Custom codec (instead of default JSON)
pub := herald.NewPublisher(provider, signal, key, opts,
    herald.WithPublisherCodec[Order](MsgpackCodec{}),
)
```

## Subscribers

A **Subscriber** consumes messages from a broker and emits them as capitan events.

### Creating Subscribers

```go
// Define signal and key
orderReceived := capitan.NewSignal("order.received", "Order received")
orderKey := capitan.NewKey[Order]("order", "app.Order")

// Create subscriber
sub := herald.NewSubscriber(provider, orderReceived, orderKey, nil)

// Start consuming
sub.Start(ctx)

// Handle messages as capitan events
capitan.Hook(orderReceived, func(ctx context.Context, e *capitan.Event) {
    order, ok := orderKey.From(e)
    if !ok {
        return
    }
    processOrder(order)
})
```

### Subscriber Lifecycle

```
┌───────────────────────────────────────────────────────┐
│                  Subscriber Lifecycle                  │
└───────────────────────────────────────────────────────┘

NewSubscriber()         Start(ctx)              Close()
     │                      │                      │
     ▼                      ▼                      ▼
┌─────────┐           ┌─────────┐           ┌─────────┐
│ Created │──────────►│ Running │──────────►│ Stopped │
│         │           │         │           │         │
│ - No    │           │ - Reads │           │ - Stops │
│   reads │           │   from  │           │   reads │
│         │           │ channel │           │         │
└─────────┘           └─────────┘           └─────────┘
                           │
                           ▼
                      ┌─────────┐
                      │ Process │
                      │ Message │
                      │         │
                      │ Unmarshal
                      │ Pipeline │
                      │ Emit    │
                      │ Ack/Nack│
                      └─────────┘
```

### How Subscribing Works

1. Subscriber calls Provider.Subscribe() to get a message channel
2. For each message received:
   - Unmarshal to typed value using the codec (JSON by default)
   - Attach metadata to context
   - Run through pipeline
   - Emit to capitan signal
   - Ack on success, Nack on failure

```go
// Internal flow (simplified)
messages := provider.Subscribe(ctx)

for result := range messages {
    if result.IsError() {
        continue  // Provider error
    }

    msg := result.Value()

    var value T
    if err := codec.Unmarshal(msg.Data, &value); err != nil {
        msg.Nack()  // Invalid payload
        continue
    }

    // Attach metadata to context
    if msg.Metadata != nil {
        ctx = ContextWithMetadata(ctx, msg.Metadata)
    }

    // Run through pipeline (timeout, rate limit, etc.)
    _, err := pipeline.Process(ctx, value)

    if err != nil {
        msg.Nack()  // Pipeline failed
    } else {
        msg.Ack()   // Success
    }
}
```

### Subscriber Options

```go
// Pipeline options wrap the emit operation
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithRateLimit[Order](100, 10),
}

sub := herald.NewSubscriber(provider, signal, key, opts)

// Custom capitan instance
sub := herald.NewSubscriber(provider, signal, key, opts,
    herald.WithSubscriberCapitan[Order](customCapitan),
)

// Custom codec (instead of default JSON)
sub := herald.NewSubscriber(provider, signal, key, opts,
    herald.WithSubscriberCodec[Order](MsgpackCodec{}),
)
```

## Codecs

A **Codec** handles serialization and deserialization of message payloads.

### The Codec Interface

```go
type Codec interface {
    // Marshal serializes a value to bytes.
    Marshal(v any) ([]byte, error)

    // Unmarshal deserializes bytes into a value.
    Unmarshal(data []byte, v any) error

    // ContentType returns the MIME type for metadata propagation.
    ContentType() string
}
```

### Default: JSONCodec

By default, herald uses JSON serialization via `encoding/json`:

```go
type JSONCodec struct{}

func (JSONCodec) Marshal(v any) ([]byte, error)     { return json.Marshal(v) }
func (JSONCodec) Unmarshal(data []byte, v any) error { return json.Unmarshal(data, v) }
func (JSONCodec) ContentType() string                { return "application/json" }
```

### Custom Codecs

Implement the `Codec` interface for alternative formats:

```go
type MsgpackCodec struct{}

func (MsgpackCodec) Marshal(v any) ([]byte, error) {
    return msgpack.Marshal(v)
}

func (MsgpackCodec) Unmarshal(data []byte, v any) error {
    return msgpack.Unmarshal(data, v)
}

func (MsgpackCodec) ContentType() string {
    return "application/msgpack"
}

// Use with publisher
pub := herald.NewPublisher(provider, signal, key, nil,
    herald.WithPublisherCodec[Order](MsgpackCodec{}),
)

// Use with subscriber
sub := herald.NewSubscriber(provider, signal, key, nil,
    herald.WithSubscriberCodec[Order](MsgpackCodec{}),
)
```

### Content-Type Propagation

When publishing, the codec's `ContentType()` is automatically added to message metadata (unless already present). This allows subscribers to identify the serialization format used.

## Messages

A **Message** represents data received from a broker with acknowledgment controls.

### Message Structure

```go
type Message struct {
    // Data is the raw message payload (codec-serialized bytes)
    Data []byte

    // Metadata contains message headers/attributes
    Metadata Metadata

    // Ack confirms successful processing
    Ack func() error

    // Nack signals processing failure (triggers redelivery)
    Nack func() error
}
```

### Metadata

Metadata is a string-to-string map for headers/attributes:

```go
type Metadata map[string]string
```

Each provider maps metadata to broker-native headers:

| Provider | Header Format |
|----------|---------------|
| Kafka | `[]kafka.Header` |
| Pub/Sub | `Attributes` |
| SQS | `MessageAttributes` |
| AMQP | `Headers` |
| Redis | Stream fields |

### Context Propagation

Metadata flows through context:

```go
// Attach metadata before emit
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc-123",
})
capitan.Emit(ctx, signal, key.Field(order))

// Extract metadata in handlers
capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]
})
```

### Ack/Nack Semantics

Acknowledgment behavior varies by broker:

| Broker | Ack Behavior | Nack Behavior |
|--------|--------------|---------------|
| Kafka | Commit offset | No action (reprocess on restart) |
| SQS | Delete message | Return to queue (after visibility timeout) |
| Pub/Sub | Acknowledge | Nack (redelivery) |
| NATS | Ack (JetStream) | Nak (redelivery) |
| RabbitMQ | Ack | Nack with requeue |
| Redis | XACK | No action |

Herald automatically calls Ack/Nack based on pipeline success/failure:

```go
// Subscriber internal logic
_, err := pipeline.Process(ctx, value)

if err != nil {
    msg.Nack()  // Trigger redelivery
} else {
    msg.Ack()   // Confirm processing
}
```

## Result Type

Herald uses a generic `Result[T]` type for error handling in channels:

```go
type Result[T any] struct {
    value T
    err   error
}

func (r Result[T]) Value() T        { return r.value }
func (r Result[T]) Error() error    { return r.err }
func (r Result[T]) IsError() bool   { return r.err != nil }
func (r Result[T]) IsSuccess() bool { return r.err == nil }
```

Providers return `<-chan Result[Message]` to handle both messages and errors:

```go
messages := provider.Subscribe(ctx)

for result := range messages {
    if result.IsError() {
        log.Printf("Subscription error: %v", result.Error())
        continue
    }

    msg := result.Value()
    // Process message...
}
```

## Best Practices

### 1. One Direction Per Signal

A node should be Publisher OR Subscriber for a signal, not both:

```go
// ✅ Service A publishes
pub := herald.NewPublisher(kafka, orderCreated, orderKey, nil)

// ✅ Service B subscribes
sub := herald.NewSubscriber(kafka, orderCreated, orderKey, nil)

// ❌ Don't do both in same service
pub := herald.NewPublisher(kafka, orderCreated, orderKey, nil)
sub := herald.NewSubscriber(kafka, orderCreated, orderKey, nil)
```

### 2. Define Signals as Constants

```go
package signals

var (
    OrderCreated  = capitan.NewSignal("order.created", "Order created")
    OrderShipped  = capitan.NewSignal("order.shipped", "Order shipped")
    OrderReceived = capitan.NewSignal("order.received", "Order received from queue")
)
```

### 3. Close Resources Properly

```go
pub := herald.NewPublisher(provider, signal, key, nil)
pub.Start(ctx)
defer pub.Close()

// ... application runs ...

// On shutdown:
capitan.Shutdown()  // Drain capitan queues
pub.Close()         // Close publisher
provider.Close()    // Close broker connection
```

### 4. Use Pipeline Options for Reliability

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

## Next Steps

- [Architecture](./3.architecture.md) - Deep dive into event flow and internals
- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first integration
- [Providers Guide](../3.guides/2.providers.md) - Configuration for all 12 providers
