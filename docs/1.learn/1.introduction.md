---
title: Introduction
description: Why herald exists and how it fits into the zoobzio event coordination ecosystem.
author: Herald Team
published: 2025-12-06
tags: [Introduction, Overview, Getting Started]
---

# Introduction

## What is herald?

Herald provides bidirectional bindings between [capitan](https://github.com/zoobzio/capitan) events and message brokers. It bridges in-process event coordination with distributed messaging systems.

```
┌─────────────────┐                      ┌─────────────────┐
│    capitan      │                      │  Message Broker │
│                 │◄────── herald ────────►│                 │
│  Emit/Hook      │                      │  Kafka/SQS/...  │
└─────────────────┘                      └─────────────────┘
```

**Publishers** observe capitan signals and forward them to broker topics.
**Subscribers** consume from broker topics and emit to capitan signals.

## Why herald?

### The Problem

Modern applications need both:

1. **In-process event coordination** - Decouple components within a service
2. **Distributed messaging** - Communicate across services and systems

Without herald, you end up with two separate systems:

```go
// In-process events (capitan)
capitan.Hook(orderCreated, sendConfirmationEmail)
capitan.Hook(orderCreated, updateInventory)

// Distributed messages (direct broker usage)
kafka.Produce(ctx, "orders", orderBytes)
kafka.Consume(ctx, "orders", func(msg kafka.Message) {
    // Manual deserialization, error handling...
})
```

This creates:
- Duplicate event definitions
- Manual serialization/deserialization
- Inconsistent error handling
- No unified observability

### The Solution

Herald unifies both models:

```go
// Define once
orderCreated := capitan.NewSignal("order.created", "Order created")
orderKey := capitan.NewKey[Order]("order", "app.Order")

// Local handlers (capitan)
capitan.Hook(orderCreated, sendConfirmationEmail)
capitan.Hook(orderCreated, updateInventory)

// Publish to Kafka (herald)
pub := herald.NewPublisher(kafkaProvider, orderCreated, orderKey, nil)
pub.Start(ctx)

// One emit reaches both local handlers AND Kafka
capitan.Emit(ctx, orderCreated, orderKey.Field(order))
```

On the consuming side:

```go
// Subscribe from Kafka (herald)
sub := herald.NewSubscriber(kafkaProvider, orderReceived, orderKey, nil)
sub.Start(ctx)

// Handle messages as capitan events
capitan.Hook(orderReceived, processOrder)
```

## Core Principles

### 1. Type Safety

Publishers and subscribers are generic. Type mismatches are caught at compile time:

```go
// Type is part of the definition
orderKey := capitan.NewKey[Order]("order", "app.Order")

// Publisher is typed
pub := herald.NewPublisher[Order](provider, signal, orderKey, nil)

// Wrong type won't compile
pub := herald.NewPublisher[User](provider, signal, orderKey, nil) // ✗ Compile error
```

### 2. Bidirectional Flow

Herald works in both directions:

```
Publish Direction:
capitan.Emit() → Publisher → Broker

Subscribe Direction:
Broker → Subscriber → capitan.Emit()
```

A service can be a publisher for some signals and a subscriber for others.

### 3. Provider Abstraction

The `Provider` interface abstracts broker differences:

```go
type Provider interface {
    Publish(ctx context.Context, data []byte, metadata Metadata) error
    Subscribe(ctx context.Context) <-chan Result[Message]
    Close() error
}
```

Switch brokers by changing the provider:

```go
// Development: embedded BoltDB
provider := bolt.New("orders", bolt.WithDB(boltDB))

// Production: Kafka
provider := kafka.New("orders", kafka.WithWriter(kafkaWriter))

// Same publisher code works with both
pub := herald.NewPublisher(provider, signal, key, nil)
```

### 4. Composable Middleware

Pipeline options wrap operations with reliability patterns:

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithBackoff[Order](3, 100*time.Millisecond),
    herald.WithRateLimit[Order](100, 10),
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

These compose via [pipz](https://github.com/zoobzio/pipz), the pipeline library.

### 5. One Direction Per Signal

A node should be either a Publisher OR Subscriber for a given signal, never both. This prevents event loops in distributed topologies:

```go
// Service A: Publishes order.created
pub := herald.NewPublisher(kafka, orderCreated, orderKey, nil)

// Service B: Subscribes to order.created
sub := herald.NewSubscriber(kafka, orderCreated, orderKey, nil)

// ✗ Don't do this - creates a loop
pub := herald.NewPublisher(kafka, orderCreated, orderKey, nil)
sub := herald.NewSubscriber(kafka, orderCreated, orderKey, nil)
```

## Ecosystem Context

Herald is part of the zoobzio event coordination ecosystem:

| Package | Purpose |
|---------|---------|
| [capitan](https://github.com/zoobzio/capitan) | Type-safe event coordination (Emit/Hook/Observe) |
| [herald](https://github.com/zoobzio/herald) | Broker bindings (this package) |
| [pipz](https://github.com/zoobzio/pipz) | Pipeline middleware (Retry, Timeout, RateLimit) |
| [shotel](https://github.com/zoobzio/shotel) | OpenTelemetry bridge (Logs, Metrics, Traces) |

### How They Connect

```go
// capitan: Core event coordination
signal := capitan.NewSignal("order.created", "Order created")
capitan.Hook(signal, handler)
capitan.Emit(ctx, signal, fields...)

// herald: Bridge to brokers
pub := herald.NewPublisher(kafkaProvider, signal, key, nil)

// pipz: Middleware (used internally by herald)
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond), // Uses pipz.Backoff
}

// shotel: Observability (observes capitan events)
sh := shotel.New(capitan.Default(), logProvider, meterProvider, traceProvider, nil)
// All capitan events (including those from herald subscribers) become OTEL signals
```

## When to Use herald

### Use herald when:

- You need to publish capitan events to external brokers
- You need to consume broker messages as capitan events
- You want type-safe, unified event handling across in-process and distributed boundaries
- You're already using capitan for in-process events

### Don't use herald when:

- You only need in-process events (use capitan directly)
- You need raw broker access with full control (use broker client libraries directly)
- Your use case doesn't fit the event model (request/response patterns, etc.)

## Next Steps

- [Core Concepts](./2.core-concepts.md) - Deep dive into Providers, Publishers, Subscribers
- [Architecture](./3.architecture.md) - Event flow and message handling
- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first integration
