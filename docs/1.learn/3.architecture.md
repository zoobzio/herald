---
title: Architecture
description: Event flow, pipeline integration, Ack/Nack semantics, and metadata propagation in herald.
author: Herald Team
published: 2025-12-06
tags: [Architecture, Internals, Design]
---

# Architecture

## System Overview

Herald sits between capitan (in-process events) and message brokers (distributed messaging):

```
┌─────────────────────────────────────────────────────────────────┐
│                      Application Layer                          │
│                                                                  │
│    capitan.Emit() ──────────────────────► capitan.Hook()        │
│         │                                       ▲                │
│         │                                       │                │
│    ┌────▼────┐                            ┌────┴────┐           │
│    │Publisher│                            │Subscriber│          │
│    │         │                            │          │          │
│    │  pipz   │                            │  pipz    │          │
│    │pipeline │                            │ pipeline │          │
│    └────┬────┘                            └────▲─────┘          │
│         │                                      │                 │
└─────────┼──────────────────────────────────────┼─────────────────┘
          │                                      │
          │         Provider Interface           │
          │                                      │
┌─────────▼──────────────────────────────────────▼─────────────────┐
│                       Provider Layer                              │
│                                                                   │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│   │  kafka   │  │   sqs    │  │   nats   │  │  pubsub  │  ...   │
│   └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘        │
│        │             │             │             │               │
└────────┼─────────────┼─────────────┼─────────────┼───────────────┘
         │             │             │             │
         ▼             ▼             ▼             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Message Brokers                             │
│     Kafka         AWS SQS         NATS      Google Pub/Sub      │
└─────────────────────────────────────────────────────────────────┘
```

## Publish Flow

When an event is emitted to capitan, the publisher intercepts and forwards to the broker:

```
┌──────────────────────────────────────────────────────────────────┐
│                        Publish Flow                               │
└──────────────────────────────────────────────────────────────────┘

Step 1: Application emits event
─────────────────────────────────
    capitan.Emit(ctx, signal, key.Field(order))
         │
         ▼

Step 2: Publisher hook fires
─────────────────────────────────
    ┌─────────────────────────────────────┐
    │ Publisher Hook (capitan.Hook)       │
    │                                      │
    │   value, ok := key.From(event)      │
    │   if !ok { return }                 │
    │                                      │
    │   // Extract metadata from context  │
    │   metadata := MetadataFromContext() │
    └─────────────────────────────────────┘
         │
         ▼

Step 3: Pipeline processing
─────────────────────────────────
    ┌─────────────────────────────────────┐
    │ Pipeline (pipz)                      │
    │                                      │
    │   ┌─────────────┐                   │
    │   │  Timeout    │ (if configured)   │
    │   └──────┬──────┘                   │
    │          ▼                           │
    │   ┌─────────────┐                   │
    │   │  Backoff    │ (if configured)   │
    │   └──────┬──────┘                   │
    │          ▼                           │
    │   ┌─────────────┐                   │
    │   │ Rate Limit  │ (if configured)   │
    │   └──────┬──────┘                   │
    │          ▼                           │
    │   ┌─────────────┐                   │
    │   │  Terminal   │                   │
    │   │  (publish)  │                   │
    │   └─────────────┘                   │
    └─────────────────────────────────────┘
         │
         ▼

Step 4: JSON serialization
─────────────────────────────────
    data, err := json.Marshal(value)
         │
         ▼

Step 5: Provider publish
─────────────────────────────────
    provider.Publish(ctx, data, metadata)
         │
         ▼

Step 6: Broker receives message
─────────────────────────────────
    ┌─────────────────────────────────────┐
    │ Message Broker                       │
    │                                      │
    │   Topic: "orders"                   │
    │   Data: {"id":"123","total":99.99}  │
    │   Headers: {"correlation-id":"abc"} │
    └─────────────────────────────────────┘
```

## Subscribe Flow

When a message arrives from the broker, the subscriber processes and emits to capitan:

```
┌──────────────────────────────────────────────────────────────────┐
│                       Subscribe Flow                              │
└──────────────────────────────────────────────────────────────────┘

Step 1: Provider receives message
─────────────────────────────────
    ┌─────────────────────────────────────┐
    │ Message Broker                       │
    │                                      │
    │   Message arrives on topic/queue    │
    └─────────────────────────────────────┘
         │
         ▼

Step 2: Provider delivers to channel
─────────────────────────────────
    messages := provider.Subscribe(ctx)
    result := <-messages
         │
         ▼

Step 3: Error check
─────────────────────────────────
    if result.IsError() {
        // Log error, continue
        continue
    }
    msg := result.Value()
         │
         ▼

Step 4: JSON deserialization
─────────────────────────────────
    var value T
    err := json.Unmarshal(msg.Data, &value)
    if err != nil {
        msg.Nack()  // Invalid JSON
        continue
    }
         │
         ▼

Step 5: Attach metadata to context
─────────────────────────────────
    if msg.Metadata != nil {
        ctx = ContextWithMetadata(ctx, msg.Metadata)
    }
         │
         ▼

Step 6: Pipeline processing
─────────────────────────────────
    ┌─────────────────────────────────────┐
    │ Pipeline (pipz)                      │
    │                                      │
    │   ┌─────────────┐                   │
    │   │  Timeout    │ (if configured)   │
    │   └──────┬──────┘                   │
    │          ▼                           │
    │   ┌─────────────┐                   │
    │   │ Rate Limit  │ (if configured)   │
    │   └──────┬──────┘                   │
    │          ▼                           │
    │   ┌─────────────┐                   │
    │   │  Terminal   │                   │
    │   │   (emit)    │                   │
    │   └─────────────┘                   │
    └─────────────────────────────────────┘
         │
         ▼

Step 7: Emit to capitan
─────────────────────────────────
    capitan.Emit(ctx, signal, key.Field(value))
         │
         ▼

Step 8: Ack/Nack based on result
─────────────────────────────────
    if err != nil {
        msg.Nack()  // Pipeline failed, trigger redelivery
    } else {
        msg.Ack()   // Success, confirm processing
    }
         │
         ▼

Step 9: Application handler receives event
─────────────────────────────────
    capitan.Hook(signal, func(ctx context.Context, e *Event) {
        order, _ := key.From(e)
        // Process order...
    })
```

## Pipeline Architecture

Herald uses [pipz](https://github.com/zoobzio/pipz) for pipeline middleware. Options wrap the terminal operation:

```
┌──────────────────────────────────────────────────────────────────┐
│                    Pipeline Composition                           │
└──────────────────────────────────────────────────────────────────┘

Options applied in reverse order (outer → inner):

    WithTimeout(5s)
    WithBackoff(3, 100ms)
    WithRateLimit(100, 10)

Resulting pipeline structure:

    ┌─────────────────────────────────────────────────────────────┐
    │ Timeout (5s)                                                 │
    │   ┌─────────────────────────────────────────────────────┐   │
    │   │ Backoff (3 attempts, 100ms base)                     │   │
    │   │   ┌─────────────────────────────────────────────┐   │   │
    │   │   │ RateLimit (100/sec, burst 10)                │   │   │
    │   │   │   ┌─────────────────────────────────────┐   │   │   │
    │   │   │   │ Terminal (publish or emit)          │   │   │   │
    │   │   │   └─────────────────────────────────────┘   │   │   │
    │   │   └─────────────────────────────────────────────┘   │   │
    │   └─────────────────────────────────────────────────────┘   │
    └─────────────────────────────────────────────────────────────┘

Execution order:
1. Timeout starts timer
2. Backoff attempts operation (with retries on failure)
3. RateLimit waits for token
4. Terminal executes (publish or emit)
```

### Pipeline for Publishers

Terminal operation: serialize and publish

```go
// Terminal operation for publisher
pipz.Apply("publish", func(ctx context.Context, value T) (T, error) {
    data, err := json.Marshal(value)
    if err != nil {
        return value, err
    }
    metadata := MetadataFromContext(ctx)
    return value, provider.Publish(ctx, data, metadata)
})
```

### Pipeline for Subscribers

Terminal operation: emit to capitan

```go
// Terminal operation for subscriber
pipz.Effect("emit", func(ctx context.Context, value T) error {
    field := key.Field(value)
    capitan.Emit(ctx, signal, field)
    return nil
})
```

## Ack/Nack Semantics

Message acknowledgment is automatic based on pipeline success.

**Important:** Ack/Nack happens after the pipeline completes and the event is emitted to capitan, but **before** your handlers run. This is by design - herald's responsibility is "deliver to capitan", not "ensure handler success".

```
Herald's domain:     [receive] → [unmarshal] → [pipeline] → [emit] → [ack]
Capitan's domain:                                                   [handlers run async]
```

If your handler fails or panics after ack, the message will not be redelivered. For handler-level delivery guarantees, implement retry logic within your handler (e.g., emit to a retry queue on failure).

```
┌──────────────────────────────────────────────────────────────────┐
│                     Ack/Nack Decision Flow                        │
└──────────────────────────────────────────────────────────────────┘

    Message Received
          │
          ▼
    ┌───────────────┐
    │ JSON Unmarshal│
    └───────┬───────┘
            │
      ┌─────┴─────┐
      │           │
    Error?      Success
      │           │
      ▼           ▼
    Nack()   ┌───────────────┐
             │   Pipeline    │
             │   Process     │
             └───────┬───────┘
                     │
               ┌─────┴─────┐
               │           │
             Error?      Success
               │           │
               ▼           ▼
             Nack()      Ack()
```

### Broker-Specific Behavior

| Broker | On Ack() | On Nack() |
|--------|----------|-----------|
| **Kafka** | Commit consumer offset | No action; reprocess if consumer restarts |
| **SQS** | Delete message from queue | Message returns after visibility timeout |
| **Pub/Sub** | Acknowledge to subscription | Nack; message redelivered |
| **NATS JetStream** | Ack to stream | Nak; message redelivered |
| **RabbitMQ** | Ack to channel | Nack with requeue |
| **Redis Streams** | XACK to consumer group | No action; pending entry remains |

### Retry with Backoff

When using `WithBackoff`, retries happen within a single message processing attempt:

```
Message received
       │
       ▼
┌──────────────────────────────────────────────────────────────┐
│ Backoff (3 attempts)                                          │
│                                                               │
│   Attempt 1 ──[fail]──► wait 100ms ──► Attempt 2 ──[fail]──► │
│                                                               │
│   wait 200ms ──► Attempt 3 ──[success]──► Ack()              │
│                                                               │
│   If all 3 fail: Nack() (let broker handle redelivery)       │
└──────────────────────────────────────────────────────────────┘
```

## Metadata Propagation

Headers flow through the system mapped to broker-native formats:

```
┌──────────────────────────────────────────────────────────────────┐
│                    Metadata Flow                                  │
└──────────────────────────────────────────────────────────────────┘

                      PUBLISH PATH
                      ────────────

Application sets metadata:
    ctx := ContextWithMetadata(ctx, Metadata{
        "correlation-id": "abc-123",
        "trace-id": "xyz-789",
    })

Publisher extracts from context:
    metadata := MetadataFromContext(ctx)

Provider maps to native format:
    ┌─────────────────────────────────────────────────────────────┐
    │ Kafka:                                                       │
    │   msg.Headers = []kafka.Header{                             │
    │     {Key: "correlation-id", Value: []byte("abc-123")},      │
    │     {Key: "trace-id", Value: []byte("xyz-789")},            │
    │   }                                                          │
    ├─────────────────────────────────────────────────────────────┤
    │ SQS:                                                         │
    │   input.MessageAttributes = map[string]*sqs.MessageAttr{    │
    │     "correlation-id": {StringValue: "abc-123"},             │
    │     "trace-id": {StringValue: "xyz-789"},                   │
    │   }                                                          │
    ├─────────────────────────────────────────────────────────────┤
    │ Pub/Sub:                                                     │
    │   msg.Attributes = map[string]string{                       │
    │     "correlation-id": "abc-123",                            │
    │     "trace-id": "xyz-789",                                  │
    │   }                                                          │
    └─────────────────────────────────────────────────────────────┘


                     SUBSCRIBE PATH
                     ──────────────

Provider extracts native headers:
    ┌─────────────────────────────────────────────────────────────┐
    │ Kafka headers → Metadata map                                 │
    │ SQS attributes → Metadata map                                │
    │ Pub/Sub attributes → Metadata map                            │
    └─────────────────────────────────────────────────────────────┘

Subscriber attaches to context:
    if msg.Metadata != nil {
        ctx = ContextWithMetadata(ctx, msg.Metadata)
    }

Handler extracts from context:
    capitan.Hook(signal, func(ctx context.Context, e *Event) {
        meta := MetadataFromContext(ctx)
        correlationID := meta["correlation-id"]
    })
```

### Providers Without Native Headers

Some providers don't support headers natively:

| Provider | Header Support |
|----------|----------------|
| NATS Core | No (ignored) |
| BoltDB | No (ignored) |
| io | No (ignored) |
| NATS JetStream | Yes |
| All others | Yes |

## Error Handling

### Publish Errors

```go
// Pipeline handles errors via pipz
// Backoff retries transient failures
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}

pub := herald.NewPublisher(provider, signal, key, opts)

// If all retries fail, error is logged but not propagated
// (capitan hooks are fire-and-forget)
```

### Subscribe Errors

```go
// Unmarshal errors: Nack immediately
var value T
if err := json.Unmarshal(msg.Data, &value); err != nil {
    msg.Nack()  // Let broker redeliver
    continue
}

// Pipeline errors: Nack after processing
_, err := pipeline.Process(ctx, value)
if err != nil {
    msg.Nack()  // Trigger redelivery
} else {
    msg.Ack()
}
```

### Provider Errors

```go
// Subscribe returns Result[Message] to handle errors
for result := range provider.Subscribe(ctx) {
    if result.IsError() {
        // Log error, continue consuming
        log.Printf("Subscription error: %v", result.Error())
        continue
    }
    msg := result.Value()
    // Process...
}
```

## Thread Safety

- **Providers**: Thread-safe for concurrent Publish/Subscribe calls
- **Publishers**: Can be shared across goroutines after Start()
- **Subscribers**: Single consumer per instance (one goroutine reads channel)
- **Metadata**: Immutable once attached to context

## Next Steps

- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first integration
- [Providers Guide](../3.guides/2.providers.md) - All 12 providers with examples
- [Pipeline Options](../3.guides/3.pipeline-options.md) - Timeout, backoff, rate limiting
