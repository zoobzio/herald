---
title: First Integration
description: Build a multi-broker workflow connecting Kafka and SQS.
author: Herald Team
published: 2025-12-06
tags: [Tutorial, Integration, Multi-Broker]
---

# First Integration

Build a real-world workflow that consumes orders from Kafka and publishes shipments to SQS.

## Scenario

An order fulfillment service that:

1. Consumes orders from Kafka
2. Processes the order (validates, reserves inventory)
3. Creates a shipment
4. Publishes the shipment to SQS for the warehouse

```
┌─────────────┐     ┌─────────────────────┐     ┌─────────────┐
│   Kafka     │────▶│  Fulfillment Service │────▶│    SQS      │
│  (orders)   │     │                       │     │ (shipments) │
└─────────────┘     └─────────────────────┘     └─────────────┘
```

## Project Structure

```
fulfillment/
├── main.go
├── events/
│   ├── orders.go
│   └── shipments.go
└── service/
    └── fulfillment.go
```

## Step 1: Define Events

`events/orders.go`:
```go
package events

import "github.com/zoobzio/capitan"

type Order struct {
    ID         string   `json:"id"`
    CustomerID string   `json:"customer_id"`
    Items      []string `json:"items"`
    Total      float64  `json:"total"`
}

var (
    OrderReceived = capitan.NewSignal("order.received", "Order received from queue")
    OrderKey      = capitan.NewKey[Order]("order", "fulfillment.Order")
)
```

`events/shipments.go`:
```go
package events

import "github.com/zoobzio/capitan"

type Shipment struct {
    ID        string   `json:"id"`
    OrderID   string   `json:"order_id"`
    Carrier   string   `json:"carrier"`
    TrackingNo string  `json:"tracking_no"`
    Items     []string `json:"items"`
}

var (
    ShipmentCreated = capitan.NewSignal("shipment.created", "Shipment ready for warehouse")
    ShipmentKey     = capitan.NewKey[Shipment]("shipment", "fulfillment.Shipment")
)
```

## Step 2: Create the Fulfillment Service

`service/fulfillment.go`:
```go
package service

import (
    "context"
    "fmt"
    "math/rand"
    "time"

    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
    "github.com/zoobzio/herald/kafka"
    "github.com/zoobzio/herald/sqs"
    "fulfillment/events"
)

type FulfillmentService struct {
    orderSub    *herald.Subscriber[events.Order]
    shipmentPub *herald.Publisher[events.Shipment]
    kafkaProv   herald.Provider
    sqsProv     herald.Provider
    kafkaReader *kafkago.Reader
    sqsClient   sqs.Client
    listener    *capitan.Listener
}

func New(kafkaBrokers []string, sqsQueueURL string, sqsClient sqs.Client) (*FulfillmentService, error) {
    // Kafka reader for orders
    kafkaReader := kafkago.NewReader(kafkago.ReaderConfig{
        Brokers: kafkaBrokers,
        Topic:   "orders",
        GroupID: "fulfillment-service",
    })

    // Kafka provider
    kafkaProv := kafka.New("orders",
        kafka.WithReader(kafkaReader),
    )

    // SQS provider for shipments
    sqsProv := sqs.New(sqsQueueURL,
        sqs.WithClient(sqsClient),
    )

    return &FulfillmentService{
        kafkaProv:   kafkaProv,
        sqsProv:     sqsProv,
        kafkaReader: kafkaReader,
        sqsClient:   sqsClient,
    }, nil
}

func (s *FulfillmentService) Start(ctx context.Context) error {
    // Create subscriber for orders
    orderOpts := []herald.Option[events.Order]{
        herald.WithTimeout[events.Order](30 * time.Second),
        herald.WithRateLimit[events.Order](50, 10), // 50/sec, burst 10
    }
    s.orderSub = herald.NewSubscriber(s.kafkaProv, events.OrderReceived, events.OrderKey, orderOpts)
    s.orderSub.Start(ctx)

    // Create publisher for shipments
    shipmentOpts := []herald.Option[events.Shipment]{
        herald.WithTimeout[events.Shipment](10 * time.Second),
        herald.WithBackoff[events.Shipment](3, 200*time.Millisecond),
    }
    s.shipmentPub = herald.NewPublisher(s.sqsProv, events.ShipmentCreated, events.ShipmentKey, shipmentOpts)
    s.shipmentPub.Start(ctx)

    // Hook to process orders
    s.listener = capitan.Hook(events.OrderReceived, s.handleOrder)

    return nil
}

func (s *FulfillmentService) handleOrder(ctx context.Context, e *capitan.Event) {
    order, ok := events.OrderKey.From(e)
    if !ok {
        return
    }

    // Extract correlation ID from incoming message
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]
    if correlationID == "" {
        correlationID = generateID()
    }

    fmt.Printf("[%s] Processing order %s\n", correlationID, order.ID)

    // Validate order
    if err := validateOrder(order); err != nil {
        fmt.Printf("[%s] Order validation failed: %v\n", correlationID, err)
        return
    }

    // Reserve inventory
    if err := reserveInventory(order.Items); err != nil {
        fmt.Printf("[%s] Inventory reservation failed: %v\n", correlationID, err)
        return
    }

    // Create shipment
    shipment := events.Shipment{
        ID:         generateID(),
        OrderID:    order.ID,
        Carrier:    selectCarrier(order),
        TrackingNo: generateTrackingNo(),
        Items:      order.Items,
    }

    // Propagate correlation ID to shipment
    ctx = herald.ContextWithMetadata(ctx, herald.Metadata{
        "correlation-id": correlationID,
        "source":         "fulfillment-service",
    })

    // Emit shipment - published to SQS
    capitan.Emit(ctx, events.ShipmentCreated, events.ShipmentKey.Field(shipment))

    fmt.Printf("[%s] Created shipment %s for order %s\n",
        correlationID, shipment.ID, order.ID)
}

func (s *FulfillmentService) Stop() {
    if s.listener != nil {
        s.listener.Close()
    }
    if s.orderSub != nil {
        s.orderSub.Close()
    }
    if s.shipmentPub != nil {
        s.shipmentPub.Close()
    }
    if s.kafkaProv != nil {
        s.kafkaProv.Close()
    }
    if s.sqsProv != nil {
        s.sqsProv.Close()
    }
    if s.kafkaReader != nil {
        s.kafkaReader.Close()
    }
    capitan.Shutdown()
}

// Business logic helpers

func validateOrder(order events.Order) error {
    if len(order.Items) == 0 {
        return fmt.Errorf("order has no items")
    }
    if order.Total <= 0 {
        return fmt.Errorf("invalid order total")
    }
    return nil
}

func reserveInventory(items []string) error {
    // Simulate inventory check
    time.Sleep(50 * time.Millisecond)
    return nil
}

func selectCarrier(order events.Order) string {
    carriers := []string{"fedex", "ups", "usps", "dhl"}
    return carriers[rand.Intn(len(carriers))]
}

func generateID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

func generateTrackingNo() string {
    return fmt.Sprintf("TRK%d", rand.Int63n(1000000000))
}
```

## Step 3: Main Entry Point

`main.go`:
```go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "syscall"

    "fulfillment/service"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // Configuration (use environment variables in production)
    kafkaBrokers := []string{"localhost:9092"}
    sqsQueueURL := "https://sqs.us-east-1.amazonaws.com/123456789/shipments"

    // Create SQS client (implement sqs.Client interface)
    sqsClient := createSQSClient() // Your AWS SDK wrapper

    // Create service
    svc, err := service.New(kafkaBrokers, sqsQueueURL, sqsClient)
    if err != nil {
        fmt.Printf("Failed to create service: %v\n", err)
        os.Exit(1)
    }

    // Start service
    if err := svc.Start(ctx); err != nil {
        fmt.Printf("Failed to start service: %v\n", err)
        os.Exit(1)
    }

    fmt.Println("Fulfillment service started")
    fmt.Println("Consuming orders from Kafka, publishing shipments to SQS")

    // Wait for interrupt
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh

    fmt.Println("\nShutting down...")
    cancel()
    svc.Stop()
    fmt.Println("Goodbye")
}
```

## Step 4: Testing with io Provider

For unit tests, use the `io` provider instead of real brokers:

```go
package service_test

import (
    "context"
    "encoding/json"
    "io"
    "strings"
    "sync"
    "testing"
    "time"

    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
    heraldio "github.com/zoobzio/herald/io"
    "fulfillment/events"
)

func TestFulfillmentFlow(t *testing.T) {
    ctx := context.Background()

    // Create isolated capitan for testing
    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    // Input: order as JSON
    order := events.Order{
        ID:         "TEST-001",
        CustomerID: "CUST-001",
        Items:      []string{"item-1", "item-2"},
        Total:      99.99,
    }
    orderJSON, _ := json.Marshal(order)

    // Create io providers
    orderReader := heraldio.New(heraldio.WithReader(strings.NewReader(string(orderJSON) + "\n")))

    var shipmentBuf strings.Builder
    shipmentWriter := heraldio.New(heraldio.WithWriter(&shipmentBuf))

    // Create subscriber for orders
    orderSub := herald.NewSubscriber(orderReader, events.OrderReceived, events.OrderKey, nil,
        herald.WithSubscriberCapitan[events.Order](c),
    )
    orderSub.Start(ctx)

    // Create publisher for shipments
    shipmentPub := herald.NewPublisher(shipmentWriter, events.ShipmentCreated, events.ShipmentKey, nil,
        herald.WithPublisherCapitan[events.Shipment](c),
    )
    shipmentPub.Start(ctx)

    // Track shipments
    var receivedShipment events.Shipment
    var wg sync.WaitGroup
    wg.Add(1)

    c.Hook(events.ShipmentCreated, func(ctx context.Context, e *capitan.Event) {
        shipment, ok := events.ShipmentKey.From(e)
        if ok {
            receivedShipment = shipment
            wg.Done()
        }
    })

    // Process order → create shipment
    c.Hook(events.OrderReceived, func(ctx context.Context, e *capitan.Event) {
        order, ok := events.OrderKey.From(e)
        if !ok {
            return
        }

        shipment := events.Shipment{
            ID:        "SHIP-001",
            OrderID:   order.ID,
            Carrier:   "fedex",
            Items:     order.Items,
        }

        c.Emit(ctx, events.ShipmentCreated, events.ShipmentKey.Field(shipment))
    })

    // Wait for flow to complete
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(2 * time.Second):
        t.Fatal("timeout waiting for shipment")
    }

    // Verify
    if receivedShipment.OrderID != "TEST-001" {
        t.Errorf("expected OrderID 'TEST-001', got %q", receivedShipment.OrderID)
    }

    // Cleanup
    orderSub.Close()
    shipmentPub.Close()
}
```

## Event Flow Visualization

```
┌──────────────────────────────────────────────────────────────────┐
│                    Fulfillment Service                           │
└──────────────────────────────────────────────────────────────────┘

                         INBOUND
┌─────────────┐     ┌────────────────┐     ┌─────────────────┐
│    Kafka    │────▶│   Subscriber   │────▶│ order.received  │
│   "orders"  │     │                │     │     signal      │
└─────────────┘     └────────────────┘     └────────┬────────┘
                                                     │
                                                     ▼
                                           ┌─────────────────┐
                                           │  handleOrder()  │
                                           │                 │
                                           │  - Validate     │
                                           │  - Reserve      │
                                           │  - Create ship  │
                                           └────────┬────────┘
                                                     │
                         OUTBOUND                    │
┌─────────────┐     ┌────────────────┐     ┌────────▼────────┐
│    SQS      │◀────│   Publisher    │◀────│shipment.created │
│ "shipments" │     │                │     │     signal      │
└─────────────┘     └────────────────┘     └─────────────────┘
```

## Production Considerations

### Error Handling

```go
func (s *FulfillmentService) handleOrder(ctx context.Context, e *capitan.Event) {
    order, ok := events.OrderKey.From(e)
    if !ok {
        // Log and return - message will be Ack'd (no point retrying bad data)
        log.Warn("Failed to extract order from event")
        return
    }

    // Wrap processing in panic recovery
    defer func() {
        if r := recover(); r != nil {
            log.Errorf("Panic processing order %s: %v", order.ID, r)
        }
    }()

    // ... processing logic ...
}
```

### Graceful Shutdown

```go
func (s *FulfillmentService) Stop() {
    // 1. Stop accepting new messages
    if s.orderSub != nil {
        s.orderSub.Close()
    }

    // 2. Wait for in-flight processing
    capitan.Shutdown() // Drains queues

    // 3. Close publisher
    if s.shipmentPub != nil {
        s.shipmentPub.Close()
    }

    // 4. Close provider connections
    if s.kafkaProv != nil {
        s.kafkaProv.Close()
    }
    if s.sqsProv != nil {
        s.sqsProv.Close()
    }
}
```

### Observability

With shotel, all events become observable:

```go
import "github.com/zoobzio/shotel"

// In main.go
pvs, _ := shotel.DefaultProviders(ctx, "fulfillment-service", "v1.0.0", "localhost:4318")
defer pvs.Shutdown(ctx)

sh, _ := shotel.New(capitan.Default(), pvs.Log, pvs.Meter, pvs.Trace, &shotel.Config{
    Metrics: []shotel.MetricConfig{
        {Signal: events.OrderReceived, Name: "orders_received_total"},
        {Signal: events.ShipmentCreated, Name: "shipments_created_total"},
    },
})
defer sh.Close()
```

## Next Steps

- [Testing Guide](../3.guides/1.testing.md) - More testing patterns
- [Providers Guide](../3.guides/2.providers.md) - Configure all 12 providers
- [Error Handling Cookbook](../4.cookbook/3.error-handling.md) - Advanced patterns
