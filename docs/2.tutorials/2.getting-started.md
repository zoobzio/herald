---
title: Getting Started
description: Complete introduction to herald with real broker examples.
author: Herald Team
published: 2025-12-06
tags: [Tutorial, Getting Started, Kafka]
---

# Getting Started

This tutorial walks through a complete herald integration using Kafka as the message broker.

## Prerequisites

- Go 1.23+
- Docker (for running Kafka locally)
- Basic familiarity with capitan

## Setup Kafka

Start a local Kafka instance:

```bash
docker run -d --name kafka \
  -p 9092:9092 \
  -e KAFKA_CFG_NODE_ID=0 \
  -e KAFKA_CFG_PROCESS_ROLES=controller,broker \
  -e KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 \
  -e KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT \
  -e KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@localhost:9093 \
  -e KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER \
  -e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 \
  bitnami/kafka:latest
```

## Installation

```bash
go get github.com/zoobzio/herald
go get github.com/zoobzio/herald/kafka
go get github.com/zoobzio/capitan
```

## Project Structure

```
myapp/
├── main.go
├── events/
│   └── orders.go
├── publisher/
│   └── publisher.go
└── subscriber/
    └── subscriber.go
```

## Step 1: Define Events

Create `events/orders.go`:

```go
package events

import "github.com/zoobzio/capitan"

// Order is our message contract
type Order struct {
    ID         string  `json:"id"`
    CustomerID string  `json:"customer_id"`
    Total      float64 `json:"total"`
    Status     string  `json:"status"`
}

// Signals
var (
    // For publishing to Kafka
    OrderCreated = capitan.NewSignal("order.created", "New order has been created")

    // For receiving from Kafka
    OrderReceived = capitan.NewSignal("order.received", "Order received from queue")
)

// Keys
var (
    OrderKey = capitan.NewKey[Order]("order", "myapp.Order")
)
```

## Step 2: Create a Publisher Service

Create `publisher/publisher.go`:

```go
package main

import (
    "context"
    "fmt"
    "time"

    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
    "github.com/zoobzio/herald/kafka"
    "myapp/events"
)

func main() {
    ctx := context.Background()

    // Create Kafka writer
    writer := &kafkago.Writer{
        Addr:     kafkago.TCP("localhost:9092"),
        Topic:    "orders",
        Balancer: &kafkago.LeastBytes{},
    }
    defer writer.Close()

    // Create Kafka provider
    provider := kafka.New("orders",
        kafka.WithWriter(writer),
    )
    defer provider.Close()

    // Create publisher with options
    opts := []herald.Option[events.Order]{
        herald.WithTimeout[events.Order](5 * time.Second),
        herald.WithBackoff[events.Order](3, 100*time.Millisecond),
    }

    pub := herald.NewPublisher(provider, events.OrderCreated, events.OrderKey, opts)
    pub.Start(ctx)
    defer pub.Close()

    // Publish some orders
    for i := 1; i <= 5; i++ {
        order := events.Order{
            ID:         fmt.Sprintf("ORDER-%d", i),
            CustomerID: fmt.Sprintf("CUST-%d", i),
            Total:      float64(i) * 25.00,
            Status:     "pending",
        }

        fmt.Printf("Publishing order: %s\n", order.ID)
        capitan.Emit(ctx, events.OrderCreated, events.OrderKey.Field(order))

        time.Sleep(500 * time.Millisecond)
    }

    fmt.Println("All orders published")
    capitan.Shutdown()
}
```

## Step 3: Create a Subscriber Service

Create `subscriber/subscriber.go`:

```go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"

    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
    "github.com/zoobzio/herald/kafka"
    "myapp/events"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // Create Kafka reader with consumer group
    reader := kafkago.NewReader(kafkago.ReaderConfig{
        Brokers: []string{"localhost:9092"},
        Topic:   "orders",
        GroupID: "order-processor",
    })
    defer reader.Close()

    // Create Kafka provider
    provider := kafka.New("orders",
        kafka.WithReader(reader),
    )
    defer provider.Close()

    // Create subscriber with rate limiting
    opts := []herald.Option[events.Order]{
        herald.WithRateLimit[events.Order](10, 5), // 10/sec, burst 5
    }

    sub := herald.NewSubscriber(provider, events.OrderReceived, events.OrderKey, opts)
    sub.Start(ctx)
    defer sub.Close()

    // Handle received orders
    capitan.Hook(events.OrderReceived, func(ctx context.Context, e *capitan.Event) {
        order, ok := events.OrderKey.From(e)
        if !ok {
            return
        }

        fmt.Printf("Received order: %s (Customer: %s, Total: $%.2f)\n",
            order.ID, order.CustomerID, order.Total)

        // Simulate processing
        processOrder(order)
    })

    fmt.Println("Subscriber started. Waiting for orders...")

    // Wait for interrupt signal
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh

    fmt.Println("\nShutting down...")
    cancel()
    capitan.Shutdown()
}

func processOrder(order events.Order) {
    // Simulate work
    time.Sleep(100 * time.Millisecond)
    fmt.Printf("  → Processed order %s\n", order.ID)
}
```

## Step 4: Run the Services

Terminal 1 - Start the subscriber:
```bash
go run subscriber/subscriber.go
```

Output:
```
Subscriber started. Waiting for orders...
```

Terminal 2 - Run the publisher:
```bash
go run publisher/publisher.go
```

Output:
```
Publishing order: ORDER-1
Publishing order: ORDER-2
Publishing order: ORDER-3
Publishing order: ORDER-4
Publishing order: ORDER-5
All orders published
```

Terminal 1 (subscriber) will show:
```
Received order: ORDER-1 (Customer: CUST-1, Total: $25.00)
  → Processed order ORDER-1
Received order: ORDER-2 (Customer: CUST-2, Total: $50.00)
  → Processed order ORDER-2
Received order: ORDER-3 (Customer: CUST-3, Total: $75.00)
  → Processed order ORDER-3
Received order: ORDER-4 (Customer: CUST-4, Total: $100.00)
  → Processed order ORDER-4
Received order: ORDER-5 (Customer: CUST-5, Total: $125.00)
  → Processed order ORDER-5
```

## Adding Metadata

Propagate correlation IDs across services:

**Publisher:**
```go
// Attach metadata before emit
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": generateCorrelationID(),
    "source":         "order-api",
})

capitan.Emit(ctx, events.OrderCreated, events.OrderKey.Field(order))
```

**Subscriber:**
```go
capitan.Hook(events.OrderReceived, func(ctx context.Context, e *capitan.Event) {
    // Extract metadata
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]
    source := meta["source"]

    order, ok := events.OrderKey.From(e)
    if !ok {
        return
    }

    fmt.Printf("[%s] Order %s from %s\n", correlationID, order.ID, source)
})
```

## Using a Custom Capitan Instance

For isolated event handling:

```go
// Create isolated capitan instance
c := capitan.New(capitan.WithSyncMode()) // Sync mode for testing
defer c.Shutdown()

// Use custom instance with publisher
pub := herald.NewPublisher(provider, signal, key, nil,
    herald.WithPublisherCapitan[events.Order](c),
)

// Use custom instance with subscriber
sub := herald.NewSubscriber(provider, signal, key, nil,
    herald.WithSubscriberCapitan[events.Order](c),
)

// Hook on the custom instance
c.Hook(events.OrderReceived, handler)

// Emit on the custom instance
c.Emit(ctx, events.OrderCreated, events.OrderKey.Field(order))
```

## Error Handling

### Publisher Errors

Pipeline options handle transient failures:

```go
opts := []herald.Option[events.Order]{
    herald.WithTimeout[events.Order](5 * time.Second),
    herald.WithBackoff[events.Order](3, 100*time.Millisecond), // Retry 3 times
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

### Subscriber Errors

Failed processing triggers Nack (redelivery):

```go
capitan.Hook(events.OrderReceived, func(ctx context.Context, e *capitan.Event) {
    order, ok := events.OrderKey.From(e)
    if !ok {
        return // Invalid data, will be Nack'd
    }

    if err := processOrder(order); err != nil {
        // Error in handler doesn't affect Ack/Nack
        // (pipeline already succeeded at this point)
        // Log and handle appropriately
        log.Printf("Processing error: %v", err)
    }
})
```

For pipeline-level error handling, use custom pipz middleware:

```go
opts := []herald.Option[events.Order]{
    herald.WithPipeline[events.Order](
        pipz.Apply("validate", func(ctx context.Context, o events.Order) (events.Order, error) {
            if o.Total <= 0 {
                return o, errors.New("invalid order total")
            }
            return o, nil
        }),
    ),
}

sub := herald.NewSubscriber(provider, signal, key, opts)
// Invalid orders will be Nack'd
```

## Cleanup

Stop Kafka when done:

```bash
docker stop kafka
docker rm kafka
```

## Next Steps

- [First Integration](./3.first-integration.md) - Multi-broker workflow
- [Providers Guide](../3.guides/2.providers.md) - All 12 providers
- [Pipeline Options](../3.guides/3.pipeline-options.md) - Advanced middleware
- [Testing Guide](../3.guides/1.testing.md) - Test your integrations
