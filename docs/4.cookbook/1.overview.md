---
title: Cookbook Overview
description: Recipe collection for common herald patterns.
author: Herald Team
published: 2025-12-06
tags: [Cookbook, Patterns, Recipes]
---

# Cookbook Overview

This cookbook provides ready-to-use patterns for common herald scenarios.

## Recipes

### [Multi-Broker Workflows](./2.multi-broker.md)

Patterns for routing events across multiple message brokers:

- Consuming from Kafka, publishing to SQS
- Fan-out to multiple brokers
- Broker migration strategies

### [Error Handling](./3.error-handling.md)

Strategies for handling failures:

- Retry patterns with backoff
- Dead letter queue simulation
- Validation without infinite redelivery
- Circuit breaker integration

## Quick Patterns

### Basic Publisher

```go
import kafkago "github.com/segmentio/kafka-go"

// Create kafka-go writer
writer := &kafkago.Writer{
    Addr:  kafkago.TCP("localhost:9092"),
    Topic: "orders",
}
defer writer.Close()

provider := kafka.New("orders", kafka.WithWriter(writer))
defer provider.Close()

pub := herald.NewPublisher(provider, signal, key, nil)
pub.Start(ctx)
defer pub.Close()

capitan.Emit(ctx, signal, key.Field(order))
```

### Basic Subscriber

```go
import kafkago "github.com/segmentio/kafka-go"

// Create kafka-go reader
reader := kafkago.NewReader(kafkago.ReaderConfig{
    Brokers: []string{"localhost:9092"},
    Topic:   "orders",
    GroupID: "order-processor",
})
defer reader.Close()

provider := kafka.New("orders", kafka.WithReader(reader))
defer provider.Close()

sub := herald.NewSubscriber(provider, signal, key, nil)
sub.Start(ctx)
defer sub.Close()

capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    order, _ := key.From(e)
    processOrder(order)
})
```

### With Reliability Options

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](10 * time.Second),
    herald.WithBackoff[Order](3, 500*time.Millisecond),
    herald.WithRateLimit[Order](100, 20),
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

### With Metadata

```go
// Publish with metadata
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": correlationID,
    "source":         "order-api",
})
capitan.Emit(ctx, signal, key.Field(order))

// Subscribe and extract metadata
capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]
    // ...
})
```

### Custom Capitan Instance

```go
c := capitan.New(capitan.WithSyncMode())
defer c.Shutdown()

pub := herald.NewPublisher(provider, signal, key, nil,
    herald.WithPublisherCapitan[Order](c),
)

sub := herald.NewSubscriber(provider, signal, key, nil,
    herald.WithSubscriberCapitan[Order](c),
)
```

### Testing with io Provider

```go
// Publish to buffer
var buf strings.Builder
provider := heraldio.New(heraldio.WithWriter(&buf))

// Subscribe from string
input := `{"id":"1"}` + "\n"
provider := heraldio.New(heraldio.WithReader(strings.NewReader(input)))
```

## Pattern Index

| Pattern | Use Case | Recipe |
|---------|----------|--------|
| Cross-broker | Route between Kafka/SQS/etc | [Multi-Broker](./2.multi-broker.md) |
| Retry | Handle transient failures | [Error Handling](./3.error-handling.md) |
| Dead Letter | Handle poison messages | [Error Handling](./3.error-handling.md) |
| Validation | Filter invalid messages | [Error Handling](./3.error-handling.md) |
| Circuit Breaker | Protect downstream | [Error Handling](./3.error-handling.md) |

## See Also

- [Tutorials](../2.tutorials/) - Step-by-step guides
- [Guides](../3.guides/) - In-depth topics
- [Reference](../5.reference/) - API documentation
