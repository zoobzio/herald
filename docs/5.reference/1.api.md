---
title: API Reference
description: Complete API documentation for herald.
author: Herald Team
published: 2025-12-06
tags: [Reference, API, Documentation]
---

# API Reference

Complete API documentation for herald.

## Package herald

```go
import "github.com/zoobzio/herald"
```

## Types

### Metadata

```go
type Metadata map[string]string
```

Metadata holds message headers/attributes for cross-cutting concerns.

### Message

```go
type Message struct {
    // Data is the raw message payload.
    Data []byte

    // Metadata contains message headers/attributes.
    Metadata Metadata

    // Ack acknowledges successful processing.
    Ack func() error

    // Nack signals processing failure.
    Nack func() error
}
```

Message represents a message received from a broker with acknowledgment controls.

### Result

```go
type Result[T any] struct {
    // contains filtered or unexported fields
}
```

Result wraps a value or error for channel-based communication.

#### Methods

```go
func NewSuccess[T any](value T) Result[T]
func NewError[T any](err error) Result[T]

func (r Result[T]) Value() T
func (r Result[T]) Error() error
func (r Result[T]) IsError() bool
func (r Result[T]) IsSuccess() bool
```

### Provider

```go
type Provider interface {
    // Publish sends raw bytes with metadata to the broker.
    Publish(ctx context.Context, data []byte, metadata Metadata) error

    // Subscribe returns a stream of messages from the broker.
    Subscribe(ctx context.Context) <-chan Result[Message]

    // Close releases broker resources.
    Close() error
}
```

Provider defines the interface for message broker implementations.

---

## Publisher

### Type

```go
type Publisher[T any] struct {
    // contains filtered or unexported fields
}
```

Publisher observes a capitan signal and forwards events to a broker.

### Constructor

```go
func NewPublisher[T any](
    provider Provider,
    signal capitan.Signal,
    key capitan.GenericKey[T],
    pipelineOpts []Option[T],
    opts ...PublisherOption[T],
) *Publisher[T]
```

Creates a new Publisher.

**Parameters:**
- `provider` - Broker implementation
- `signal` - Capitan signal to observe
- `key` - Typed key for extracting values from events
- `pipelineOpts` - Pipeline middleware options (timeout, backoff, etc.)
- `opts` - Publisher-specific options

**Example:**
```go
pub := herald.NewPublisher(provider, signal, key, nil)
```

### Methods

#### Start

```go
func (p *Publisher[T]) Start(ctx context.Context)
```

Begins observing the signal and publishing to the broker.

#### Close

```go
func (p *Publisher[T]) Close() error
```

Stops the publisher and releases resources.

### Options

#### WithPublisherCapitan

```go
func WithPublisherCapitan[T any](c *capitan.Capitan) PublisherOption[T]
```

Sets a custom Capitan instance instead of the default singleton.

**Example:**
```go
c := capitan.New()
pub := herald.NewPublisher(provider, signal, key, nil,
    herald.WithPublisherCapitan[Order](c),
)
```

#### WithPublisherCodec

```go
func WithPublisherCodec[T any](c Codec) PublisherOption[T]
```

Sets a custom codec for serialization. If not specified, JSONCodec is used.

**Example:**
```go
pub := herald.NewPublisher(provider, signal, key, nil,
    herald.WithPublisherCodec[Order](MsgpackCodec{}),
)
```

---

## Subscriber

### Type

```go
type Subscriber[T any] struct {
    // contains filtered or unexported fields
}
```

Subscriber consumes from a broker and emits events to Capitan.

### Constructor

```go
func NewSubscriber[T any](
    provider Provider,
    signal capitan.Signal,
    key capitan.GenericKey[T],
    pipelineOpts []Option[T],
    opts ...SubscriberOption[T],
) *Subscriber[T]
```

Creates a new Subscriber.

**Parameters:**
- `provider` - Broker implementation
- `signal` - Capitan signal to emit to
- `key` - Typed key for creating event fields
- `pipelineOpts` - Pipeline middleware options
- `opts` - Subscriber-specific options

**Example:**
```go
sub := herald.NewSubscriber(provider, signal, key, nil)
```

### Methods

#### Start

```go
func (s *Subscriber[T]) Start(ctx context.Context)
```

Begins consuming from the broker and emitting to Capitan.

#### Close

```go
func (s *Subscriber[T]) Close() error
```

Stops the subscriber and releases resources.

### Options

#### WithSubscriberCapitan

```go
func WithSubscriberCapitan[T any](c *capitan.Capitan) SubscriberOption[T]
```

Sets a custom Capitan instance instead of the default singleton.

#### WithSubscriberCodec

```go
func WithSubscriberCodec[T any](c Codec) SubscriberOption[T]
```

Sets a custom codec for deserialization. If not specified, JSONCodec is used.

**Example:**
```go
sub := herald.NewSubscriber(provider, signal, key, nil,
    herald.WithSubscriberCodec[Order](MsgpackCodec{}),
)
```

---

## Codec

### Interface

```go
type Codec interface {
    // Marshal serializes a value to bytes.
    Marshal(v any) ([]byte, error)

    // Unmarshal deserializes bytes into a value.
    Unmarshal(data []byte, v any) error

    // ContentType returns the MIME type for metadata propagation.
    ContentType() string
}
```

Codec defines the serialization contract for message payloads. Implement this interface to use alternative formats like Protobuf, MessagePack, or Avro.

### JSONCodec

```go
type JSONCodec struct{}
```

JSONCodec is the default codec, using `encoding/json`.

**Methods:**
- `Marshal(v any) ([]byte, error)` - Serializes to JSON
- `Unmarshal(data []byte, v any) error` - Deserializes from JSON
- `ContentType() string` - Returns `"application/json"`

### Custom Codec Example

```go
type MsgpackCodec struct{}

func (MsgpackCodec) Marshal(v any) ([]byte, error) {
    return msgpack.Marshal(v)
}

func (MsgpackCodec) Unmarshal(data []byte, v any) error {
    return msgpack.Unmarshal(data, v)
}

func (MsgpackCodec) ContentType() string {
    return "application/msgpack"
}
```

### Content-Type Propagation

When publishing, the codec's `ContentType()` is automatically added to message metadata unless already present. This allows subscribers to identify the serialization format.

---

## Pipeline Options

### Type

```go
type Option[T any] func(pipz.Chainable[T]) pipz.Chainable[T]
```

Option wraps a pipeline processor with middleware.

### WithTimeout

```go
func WithTimeout[T any](d time.Duration) Option[T]
```

Enforces a maximum duration for the operation.

**Parameters:**
- `d` - Maximum duration

**Example:**
```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
}
```

### WithBackoff

```go
func WithBackoff[T any](maxAttempts int, baseDelay time.Duration) Option[T]
```

Retries failed operations with exponential backoff.

**Parameters:**
- `maxAttempts` - Maximum number of retry attempts
- `baseDelay` - Initial delay between retries (doubles each attempt)

**Example:**
```go
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}
// Delays: 100ms, 200ms, 400ms
```

### WithRetry

```go
func WithRetry[T any](maxAttempts int) Option[T]
```

Retries failed operations immediately (no delay between attempts).

**Parameters:**
- `maxAttempts` - Maximum number of retry attempts

**Example:**
```go
opts := []herald.Option[Order]{
    herald.WithRetry[Order](3), // Up to 3 attempts
}
```

### WithRateLimit

```go
func WithRateLimit[T any](rate float64, burst int) Option[T]
```

Controls throughput using token bucket rate limiting.

**Parameters:**
- `rate` - Operations per second
- `burst` - Maximum burst size

**Note:** Rate limiters should be package-level singletons for stateful tracking.

**Example:**
```go
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](100, 10), // 100/sec, burst 10
}
```

### WithCircuitBreaker

```go
func WithCircuitBreaker[T any](failures int, recovery time.Duration) Option[T]
```

Adds circuit breaker protection to prevent cascading failures.

**Parameters:**
- `failures` - Consecutive failures before opening circuit
- `recovery` - Duration to wait before half-open state

**Note:** Circuit breakers should be package-level singletons for stateful tracking.

**Example:**
```go
opts := []herald.Option[Order]{
    herald.WithCircuitBreaker[Order](5, 30*time.Second),
}
```

### WithErrorHandler

```go
func WithErrorHandler[T any](handler pipz.Chainable[*pipz.Error[T]]) Option[T]
```

Adds error handling to the pipeline.

**Parameters:**
- `handler` - Error handler that receives error context

**Example:**
```go
logErrors := pipz.Effect("log", func(ctx context.Context, e *pipz.Error[Order]) error {
    log.Error("Pipeline failed", "path", e.Path, "error", e.Err)
    return e.Err
})

opts := []herald.Option[Order]{
    herald.WithErrorHandler[Order](logErrors),
}
```

### WithPipeline

```go
func WithPipeline[T any](custom pipz.Chainable[T]) Option[T]
```

Replaces the pipeline with a custom processor. Use for advanced composition beyond the provided options.

**Note:** This replaces any default processing - use with care.

**Example:**
```go
custom := pipz.NewSequence("custom",
    pipz.Apply("validate", validateOrder),
    pipz.Transform("enrich", enrichOrder),
)

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](custom),
}
```

---

## Metadata Functions

### ContextWithMetadata

```go
func ContextWithMetadata(ctx context.Context, m Metadata) context.Context
```

Returns a new context with metadata attached.

**Example:**
```go
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc-123",
})
```

### MetadataFromContext

```go
func MetadataFromContext(ctx context.Context) Metadata
```

Extracts metadata from a context. Returns nil if no metadata present.

**Example:**
```go
meta := herald.MetadataFromContext(ctx)
if meta != nil {
    id := meta["correlation-id"]
}
```

---

## Error Signal

Herald emits error events for operational failures, enabling debugging and observability.

### Signal and Key

```go
var (
    ErrorSignal = capitan.NewSignal("herald.error", "Herald operational error")
    ErrorKey    = capitan.NewKey[Error]("error", "herald.Error")
)
```

### Error Type

```go
type Error struct {
    // Operation is the operation that failed: "publish", "subscribe", or "unmarshal"
    Operation string `json:"operation"`

    // Signal is the name of the user's signal involved in the error.
    Signal string `json:"signal"`

    // Err is the error message.
    Err string `json:"error"`

    // Nack is true if the message was nack'd for redelivery.
    Nack bool `json:"nack"`

    // Raw contains the original message bytes, if available.
    // Populated for unmarshal errors to aid debugging.
    Raw []byte `json:"raw,omitempty"`
}
```

### When Errors Are Emitted

| Scenario | Operation | Nack |
|----------|-----------|------|
| Provider returns error on subscribe | `subscribe` | false |
| JSON unmarshal fails | `unmarshal` | true |
| Subscriber pipeline fails | `subscribe` | true |
| Publisher pipeline fails | `publish` | false |

### Example: Error Logging

```go
capitan.Hook(herald.ErrorSignal, func(ctx context.Context, e *capitan.Event) {
    err, ok := herald.ErrorKey.From(e)
    if !ok {
        return
    }

    log.Error("Herald error",
        "operation", err.Operation,
        "signal", err.Signal,
        "error", err.Err,
        "nack", err.Nack,
    )

    if err.Raw != nil {
        log.Debug("Raw message", "data", string(err.Raw))
    }
})
```

---

## Complete Example

```go
package main

import (
    "context"
    "time"

    "github.com/segmentio/kafka-go"
    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
    heraldkafka "github.com/zoobzio/herald/kafka"
)

type Order struct {
    ID    string  `json:"id"`
    Total float64 `json:"total"`
}

func main() {
    ctx := context.Background()

    // Signal and key
    orderCreated := capitan.NewSignal("order.created", "Order created")
    orderKey := capitan.NewKey[Order]("order", "app.Order")

    // Kafka writer
    writer := &kafka.Writer{
        Addr:     kafka.TCP("localhost:9092"),
        Topic:    "orders",
        Balancer: &kafka.LeastBytes{},
    }
    defer writer.Close()

    // Provider
    provider := heraldkafka.New("orders",
        heraldkafka.WithWriter(writer),
    )
    defer provider.Close()

    // Pipeline options
    opts := []herald.Option[Order]{
        herald.WithTimeout[Order](10 * time.Second),
        herald.WithBackoff[Order](3, 500*time.Millisecond),
        herald.WithRateLimit[Order](100, 20),
    }

    // Publisher
    pub := herald.NewPublisher(provider, orderCreated, orderKey, opts)
    pub.Start(ctx)
    defer pub.Close()

    // Emit with metadata
    ctx = herald.ContextWithMetadata(ctx, herald.Metadata{
        "correlation-id": "abc-123",
    })
    capitan.Emit(ctx, orderCreated, orderKey.Field(Order{
        ID:    "ORD-1",
        Total: 99.99,
    }))

    capitan.Shutdown()
}
```

## See Also

- [Providers Reference](./2.providers.md) - Provider-specific APIs
- [Options Reference](./3.options.md) - Detailed option documentation
- [Core Concepts](../1.learn/2.core-concepts.md) - Conceptual overview
