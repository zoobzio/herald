---
title: Options Reference
description: Pipeline options and middleware reference.
author: Herald Team
published: 2025-12-06
tags: [Reference, Options, Pipeline]
---

# Options Reference

Detailed reference for pipeline options and middleware.

## Overview

Options wrap the terminal operation (publish or emit) with middleware:

```go
type Option[T any] func(pipz.Chainable[T]) pipz.Chainable[T]
```

Options are applied in order, wrapping from outside in:

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),    // Outer
    herald.WithBackoff[Order](3, 100*time.Millisecond), // Middle
    herald.WithRateLimit[Order](100, 10),          // Inner
}
// Result: Timeout → Backoff → RateLimit → Terminal
```

---

## WithRetry

```go
func WithRetry[T any](maxAttempts int) Option[T]
```

Retries failed operations immediately without delay.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `maxAttempts` | `int` | Maximum attempts (minimum 1) |

### Behavior

- First attempt executes immediately
- On failure, retries immediately without delay
- Stops on success or max attempts reached

### Example

```go
opts := []herald.Option[Order]{
    herald.WithRetry[Order](3),
}
// Attempt 1 → fail → Attempt 2 → fail → Attempt 3 → fail → return error
```

### Notes

- Use `WithBackoff` instead if you want delays between retries
- Context cancellation stops retries
- Final error is returned to caller

---

## WithBackoff

```go
func WithBackoff[T any](maxAttempts int, baseDelay time.Duration) Option[T]
```

Retries failed operations with exponential backoff.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `maxAttempts` | `int` | Maximum attempts (minimum 1) |
| `baseDelay` | `time.Duration` | Initial delay between retries |

### Behavior

- First attempt executes immediately
- On failure, waits `baseDelay` before retry
- Each subsequent delay doubles: `baseDelay * 2^(attempt-1)`
- Stops on success or max attempts reached

### Delay Progression

| Attempt | Delay After |
|---------|-------------|
| 1 | baseDelay |
| 2 | baseDelay × 2 |
| 3 | baseDelay × 4 |
| 4 | baseDelay × 8 |

### Example

```go
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}
// Attempt 1 → fail → wait 100ms
// Attempt 2 → fail → wait 200ms
// Attempt 3 → fail → return error
```

### Total Time Calculation

With `maxAttempts=5` and `baseDelay=500ms`:
- Max delay time: 500 + 1000 + 2000 + 4000 = 7500ms
- Plus processing time per attempt

### Notes

- Context cancellation stops retries
- All errors trigger retry (no error classification)
- Final error is returned to caller

---

## WithTimeout

```go
func WithTimeout[T any](d time.Duration) Option[T]
```

Enforces a maximum duration for the wrapped operation.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `d` | `time.Duration` | Maximum duration |

### Behavior

- Starts a timer when operation begins
- Cancels context if timer expires
- Returns `context.DeadlineExceeded` on timeout

### Example

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
}
```

### Error

```go
if errors.Is(err, context.DeadlineExceeded) {
    // Operation timed out
}
```

### Notes

- Timeout applies to entire wrapped operation
- When combined with Backoff, includes all retry attempts
- Respects parent context cancellation

---

## WithCircuitBreaker

```go
func WithCircuitBreaker[T any](failures int, recovery time.Duration) Option[T]
```

Prevents cascading failures by opening circuit after consecutive failures.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `failures` | `int` | Consecutive failures before opening |
| `recovery` | `time.Duration` | Wait time before half-open state |

### Behavior

- **Closed**: Normal operation, counting failures
- **Open**: All calls fail immediately without executing
- **Half-Open**: After recovery time, allows one test call
  - Success → Closed
  - Failure → Open

### Example

```go
opts := []herald.Option[Order]{
    herald.WithCircuitBreaker[Order](5, 30*time.Second),
}
// After 5 consecutive failures, circuit opens for 30 seconds
```

### Circuit States

```
       ┌──────────────────────────────────────────────────────┐
       │                                                       │
       │            success                 timeout            │
       │         ┌─────────┐            ┌───────────┐          │
       ▼         │         │            │           ▼          │
    ┌──────┐   ┌─┴─────────┴─┐     ┌────┴────┐    ┌────────┐  │
    │CLOSED│◄──│ HALF-OPEN   │────►│  OPEN   │────│ WAIT   │──┘
    └──────┘   └─────────────┘     └─────────┘    └────────┘
       │         failure            N failures
       │
       └───────────────────────────────────────────────────────
                    normal operation
```

### Notes

- Circuit breakers should be package-level singletons for stateful tracking
- Each Publisher/Subscriber creates its own circuit breaker instance
- Consider sharing circuit breakers across instances for external services

---

## WithRateLimit

```go
func WithRateLimit[T any](rate float64, burst int) Option[T]
```

Controls throughput using token bucket rate limiting.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `rate` | `float64` | Tokens per second |
| `burst` | `int` | Maximum tokens available |

### Behavior

- Maintains a token bucket
- Each operation consumes one token
- Tokens replenish at `rate` per second
- Operations wait if no tokens available
- `burst` allows handling spikes

### Example

```go
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](100, 10),
}
// Allows 100 ops/sec sustained
// Can burst up to 10 ops immediately
```

### Token Bucket Visualization

```
Bucket capacity: 10 tokens (burst)
Refill rate: 100 tokens/second (1 every 10ms)

Time 0:    [●●●●●●●●●●] 10 tokens
Op 1-10:   [          ] 0 tokens (10 ops consumed)
Time 10ms: [●         ] 1 token (refill)
Op 11:     [          ] 0 tokens
Time 20ms: [●         ] 1 token
Op 12:     [          ] 0 tokens
...
```

### Notes

- Operations block waiting for tokens
- Respects context cancellation
- Rate limiters should be package-level singletons for stateful tracking

---

## WithErrorHandler

```go
func WithErrorHandler[T any](handler pipz.Chainable[*pipz.Error[T]]) Option[T]
```

Adds error handling to the pipeline.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `handler` | `pipz.Chainable[*pipz.Error[T]]` | Error handler processor |

### pipz.Error Structure

```go
type Error[T any] struct {
    Path     []string      // Pipeline path to failure point
    Duration time.Duration // Time spent before failure
    Err      error         // Original error
    Value    T             // Value that caused the error
}
```

### Example: Logging Errors

```go
logErrors := pipz.Effect("log", func(ctx context.Context, e *pipz.Error[Order]) error {
    log.Error("Pipeline failed",
        "path", e.Path,
        "duration", e.Duration,
        "error", e.Err,
        "order_id", e.Value.ID,
    )
    return e.Err // Propagate error
})

opts := []herald.Option[Order]{
    herald.WithErrorHandler[Order](logErrors),
}
```

### Example: Metrics

```go
trackErrors := pipz.Effect("metrics", func(ctx context.Context, e *pipz.Error[Order]) error {
    metrics.Inc("pipeline_errors", "path", strings.Join(e.Path, "."))
    return e.Err
})

opts := []herald.Option[Order]{
    herald.WithErrorHandler[Order](trackErrors),
}
```

### Notes

- Handler receives rich error context
- Return `nil` to suppress error propagation
- Return error to continue propagating

---

## WithPipeline

```go
func WithPipeline[T any](custom pipz.Chainable[T]) Option[T]
```

Replaces the pipeline with a custom processor.

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `custom` | `pipz.Chainable[T]` | Custom processor to use |

### Behavior

**Important:** This replaces any default processing entirely. The custom pipeline becomes the new terminal operation wrapper.

### Example: Custom Sequence

```go
custom := pipz.NewSequence("order-pipeline",
    pipz.Apply("validate", validateOrder),
    pipz.Transform("enrich", enrichOrder),
    pipz.Effect("log", logOrder),
)

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](custom),
}
```

### Available pipz Processors

| Processor | Description |
|-----------|-------------|
| `Apply` | Transformation that may fail |
| `Transform` | Pure transformation |
| `Effect` | Side effect, no data change |
| `Mutate` | Conditional modification |
| `Enrich` | Best-effort enhancement |

### Available pipz Connectors

| Connector | Description |
|-----------|-------------|
| `Sequence` | Sequential execution |
| `Fallback` | Try alternatives on failure |
| `CircuitBreaker` | Prevent cascading failures |
| `Retry` | Fixed-delay retry |
| `Backoff` | Exponential backoff |
| `Timeout` | Time limit |
| `RateLimiter` | Throughput control |

See [pipz documentation](https://github.com/zoobzio/pipz) for full reference.

---

## Combining Options

Options compose in specified order:

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](30 * time.Second),     // 1. Outer
    herald.WithBackoff[Order](3, 500*time.Millisecond), // 2.
    herald.WithRateLimit[Order](100, 20),             // 3.
    herald.WithErrorHandler[Order](logErrors),        // 4. Inner
}
```

Execution:
1. Timeout timer starts (30s)
2. Backoff wrapper activated
3. Rate limiter waits for token
4. Error handler wraps terminal
5. Terminal operation (publish/emit)

### Recommended Order

```go
opts := []herald.Option[Order]{
    // 1. Overall timeout (outermost)
    herald.WithTimeout[Order](30 * time.Second),

    // 2. Circuit breaker (fail fast if downstream is down)
    herald.WithCircuitBreaker[Order](5, 30*time.Second),

    // 3. Retry logic
    herald.WithBackoff[Order](3, 500*time.Millisecond),

    // 4. Throughput control
    herald.WithRateLimit[Order](100, 20),

    // 5. Error handling (innermost)
    herald.WithErrorHandler[Order](logErrors),
}
```

---

## Publisher vs Subscriber

### Publisher Pipeline

Wraps the publish operation:

```
capitan.Emit()
    → Publisher Observer
        → Pipeline (options)
            → json.Marshal
                → provider.Publish()
```

Errors:
- Logged via error handler if configured
- No effect on original emit (fire-and-forget)

### Subscriber Pipeline

Wraps the emit operation:

```
provider.Subscribe()
    → json.Unmarshal
        → Pipeline (options)
            → capitan.Emit()
                → Ack/Nack
```

Errors:
- Pipeline error → Nack (redelivery)
- Pipeline success → Ack

### Validation Considerations

For subscribers, be careful with validation:

```go
// ❌ May cause infinite loop
validate := pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.ID == "" {
        return o, errors.New("invalid") // Error → Nack → redeliver → error...
    }
    return o, nil
})

// ✅ Drop invalid without error
validate := pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.ID == "" {
        log.Warn("Invalid order, dropping")
        return o, nil // No error → Ack
    }
    return o, nil
})
```

---

## Error Handling

### Timeout Error

```go
if errors.Is(err, context.DeadlineExceeded) {
    // Operation timed out
}
```

### Context Cancelled

```go
if errors.Is(err, context.Canceled) {
    // Parent context was cancelled
}
```

### pipz Error

```go
var pipeErr *pipz.Error[Order]
if errors.As(err, &pipeErr) {
    fmt.Printf("Failed at: %v\n", pipeErr.Path)
    fmt.Printf("Duration: %v\n", pipeErr.Duration)
    fmt.Printf("Cause: %v\n", pipeErr.Err)
}
```

---

## Performance

| Option | Overhead |
|--------|----------|
| Timeout | ~10ns + timer allocation |
| Retry | ~10ns per attempt |
| Backoff | ~10ns per attempt + sleep |
| CircuitBreaker | ~10ns + state check |
| RateLimit | ~10ns + wait time |
| ErrorHandler | ~10ns + handler execution |
| Pipeline | Depends on middleware |

All options:
- O(1) memory per operation
- No additional goroutines (except waiting)
- Context-aware

## See Also

- [Pipeline Options Guide](../3.guides/3.pipeline-options.md) - Usage patterns
- [API Reference](./1.api.md) - Core API
- [pipz Documentation](https://github.com/zoobzio/pipz) - Middleware library
