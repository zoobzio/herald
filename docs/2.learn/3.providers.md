---
title: Providers
description: Broker implementations for herald
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Learn
  - Providers
---

# Providers

Providers implement the broker-specific communication for herald. Each provider handles connection management, message serialization, metadata mapping, and acknowledgment semantics for its target broker.

## Available Providers

| Provider | Package | Use Case |
|----------|---------|----------|
| Kafka | `herald/pkg/kafka` | High-throughput streaming |
| NATS | `herald/pkg/nats` | Lightweight cloud messaging |
| JetStream | `herald/pkg/jetstream` | NATS with persistence and headers |
| Google Pub/Sub | `herald/pkg/pubsub` | GCP managed messaging |
| Redis Streams | `herald/pkg/redis` | In-memory with persistence |
| AWS SQS | `herald/pkg/sqs` | AWS managed queues |
| RabbitMQ/AMQP | `herald/pkg/amqp` | Traditional message broker |
| AWS SNS | `herald/pkg/sns` | Pub/sub fanout |
| SQL | `herald/pkg/sql` | Database-backed queues |
| BoltDB | `herald/pkg/bolt` | Embedded local queues |
| Firestore | `herald/pkg/firestore` | Firebase/GCP document store |
| io | `herald/pkg/io` | Testing with io.Reader/Writer |

## Provider Interface

All providers implement this minimal interface:

```go
type Provider interface {
    Publish(ctx context.Context, data []byte, metadata Metadata) error
    Subscribe(ctx context.Context) <-chan Result[Message]
    Close() error
}

type Message struct {
    Data     []byte
    Metadata Metadata
    Ack      func() error
    Nack     func() error
}
```

## Quick Examples

### Kafka

```go
import (
    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/herald/pkg/kafka"
)

// Publishing
writer := &kafkago.Writer{Addr: kafkago.TCP("localhost:9092"), Topic: "orders"}
provider := kafka.New("orders", kafka.WithWriter(writer))

// Subscribing
reader := kafkago.NewReader(kafkago.ReaderConfig{
    Brokers: []string{"localhost:9092"},
    Topic:   "orders",
    GroupID: "processor",
})
provider := kafka.New("orders", kafka.WithReader(reader))
```

### NATS

```go
import (
    "github.com/nats-io/nats.go"
    herald_nats "github.com/zoobzio/herald/pkg/nats"
)

nc, _ := nats.Connect("nats://localhost:4222")
provider := herald_nats.New("orders", herald_nats.WithConn(nc))
```

### JetStream

```go
import (
    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
    herald_js "github.com/zoobzio/herald/pkg/jetstream"
)

nc, _ := nats.Connect("nats://localhost:4222")
js, _ := jetstream.New(nc)
consumer, _ := js.CreateConsumer(ctx, "ORDERS", jetstream.ConsumerConfig{...})

provider := herald_js.New("orders.created",
    herald_js.WithJetStream(js),
    herald_js.WithConsumer(consumer))
```

### Redis Streams

```go
import (
    "github.com/redis/go-redis/v9"
    herald_redis "github.com/zoobzio/herald/pkg/redis"
)

client := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
provider := herald_redis.New("orders",
    herald_redis.WithClient(client),
    herald_redis.WithGroup("processor"))
```

### AWS SQS

```go
import (
    "github.com/aws/aws-sdk-go-v2/service/sqs"
    herald_sqs "github.com/zoobzio/herald/pkg/sqs"
)

client := sqs.NewFromConfig(cfg)
provider := herald_sqs.New(queueURL, herald_sqs.WithClient(client))
```

### RabbitMQ/AMQP

```go
import (
    amqp "github.com/rabbitmq/amqp091-go"
    herald_amqp "github.com/zoobzio/herald/pkg/amqp"
)

conn, _ := amqp.Dial("amqp://guest:guest@localhost:5672/")
ch, _ := conn.Channel()
provider := herald_amqp.New("orders",
    herald_amqp.WithChannel(ch),
    herald_amqp.WithQueue("orders-queue"))
```

### SQL

```go
import (
    "database/sql"
    _ "github.com/lib/pq"
    herald_sql "github.com/zoobzio/herald/pkg/sql"
)

db, _ := sql.Open("postgres", connStr)
adapter := herald_sql.NewPostgresAdapter(db)
provider := herald_sql.New("orders", herald_sql.WithDB(adapter))
```

### BoltDB

```go
import (
    "go.etcd.io/bbolt"
    herald_bolt "github.com/zoobzio/herald/pkg/bolt"
)

db, _ := bbolt.Open("queue.db", 0600, nil)
provider := herald_bolt.New("orders", herald_bolt.WithDB(db))
```

## Metadata Support

Metadata handling varies by provider:

| Provider | Publish | Subscribe |
|----------|---------|-----------|
| Kafka | Headers | Headers |
| JetStream | Headers | Headers |
| NATS | Ignored | N/A |
| Pub/Sub | Attributes | Attributes |
| Redis | Stream fields | Stream fields |
| SQS | Message attributes | Message attributes |
| AMQP | Headers | Headers |
| SNS | Message attributes | N/A |
| SQL | JSON column | JSON column |
| BoltDB | Ignored | N/A |
| Firestore | Document fields | Document fields |

## Acknowledgment Semantics

| Provider | Ack | Nack |
|----------|-----|------|
| Kafka | Commit offset | Don't commit |
| JetStream | `msg.Ack()` | `msg.Nak()` |
| NATS | No-op | No-op |
| Pub/Sub | `msg.Ack()` | `msg.Nack()` |
| Redis | `XACK` | Remains pending |
| SQS | Delete message | Visibility timeout |
| AMQP | `Ack(false)` | `Nack(false, true)` |
| SNS | N/A | N/A |
| SQL | Delete row | Remains |
| BoltDB | Delete key | Remains |
| Firestore | Delete document | Remains |

## Custom Providers

Implement the `Provider` interface for custom brokers:

```go
type MyProvider struct {
    // broker client
}

func (p *MyProvider) Publish(ctx context.Context, data []byte, meta herald.Metadata) error {
    // Send to broker with metadata
    return nil
}

func (p *MyProvider) Subscribe(ctx context.Context) <-chan herald.Result[herald.Message] {
    out := make(chan herald.Result[herald.Message])

    go func() {
        defer close(out)
        for {
            select {
            case <-ctx.Done():
                return
            default:
                msg, err := p.fetchMessage(ctx)
                if err != nil {
                    out <- herald.NewError[herald.Message](err)
                    continue
                }
                out <- herald.NewSuccess(herald.Message{
                    Data:     msg.Body,
                    Metadata: msg.Headers,
                    Ack:      func() error { return p.ack(msg) },
                    Nack:     func() error { return p.nack(msg) },
                })
            }
        }
    }()

    return out
}

func (p *MyProvider) Close() error {
    // Cleanup
    return nil
}
```

## Choosing a Provider

| Requirement | Recommended |
|-------------|-------------|
| High throughput, ordering | Kafka |
| Low latency, simple | NATS |
| Persistence + headers | JetStream |
| AWS native | SQS/SNS |
| GCP native | Pub/Sub |
| Redis already in stack | Redis Streams |
| Traditional enterprise | RabbitMQ |
| Embedded/local dev | BoltDB |
| Audit trail needed | SQL |
| Testing | io |
