---
title: Providers
description: Configuration and usage for all 11 herald providers.
author: Herald Team
published: 2025-12-06
tags: [Guide, Providers, Configuration]
---

# Providers

This guide covers configuration and usage for all 11 herald providers.

## Overview

| Provider | Package | Use Case | Metadata Support |
|----------|---------|----------|------------------|
| Kafka | `herald/kafka` | High-throughput streaming | Yes (Headers) |
| NATS | `herald/nats` | Lightweight cloud messaging | No |
| Google Pub/Sub | `herald/pubsub` | GCP managed messaging | Yes (Attributes) |
| Redis Streams | `herald/redis` | In-memory with persistence | Yes (Fields) |
| AWS SQS | `herald/sqs` | AWS managed queues | Yes (MessageAttributes) |
| RabbitMQ/AMQP | `herald/amqp` | Traditional message broker | Yes (Headers) |
| AWS SNS | `herald/sns` | Pub/sub fanout (publish only) | Yes (MessageAttributes) |
| SQL | `herald/sql` | Database-backed queues | Yes (metadata column) |
| BoltDB | `herald/bolt` | Embedded local queues | No |
| Firestore | `herald/firestore` | Firebase/GCP document store | Yes (Document fields) |
| io | `herald/io` | Testing with io.Reader/Writer | No |

## Interface-Based Design

All providers use interface-based options. This means you create the underlying client yourself and pass it to the provider. This design:

- Keeps herald's dependencies minimal
- Allows mocking for tests
- Gives you full control over client configuration
- Avoids vendor lock-in

```go
// Pattern: Create vendor client, wrap with provider
vendorClient := createVendorClient(...)  // Your configuration
provider := herald<package>.New("topic",
    herald<package>.With<Interface>(vendorClient),
)
```

---

## Kafka

High-throughput distributed streaming platform.

### Installation

```bash
go get github.com/zoobzio/herald/kafka
go get github.com/segmentio/kafka-go
```

### Usage

```go
import (
    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/herald/kafka"
)

// Create kafka-go writer for publishing
writer := &kafkago.Writer{
    Addr:     kafkago.TCP("localhost:9092"),
    Topic:    "orders",
    Balancer: &kafkago.LeastBytes{},
}
defer writer.Close()

// Create kafka-go reader for consuming
reader := kafkago.NewReader(kafkago.ReaderConfig{
    Brokers: []string{"localhost:9092"},
    Topic:   "orders",
    GroupID: "order-service",
})
defer reader.Close()

// Create provider
provider := kafka.New("orders",
    kafka.WithWriter(writer),
    kafka.WithReader(reader),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithWriter(w)` | kafka-go Writer for publishing |
| `WithReader(r)` | kafka-go Reader for consuming |

### Metadata Mapping

```go
// Metadata maps to Kafka headers
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: kafka.Header{Key: "correlation-id", Value: []byte("abc")}
```

### Notes

- GroupID on reader is required for Subscribe operations
- Ack commits the consumer offset
- Nack does nothing (message won't be redelivered until consumer restarts)

---

## NATS

Lightweight, high-performance cloud messaging.

### Installation

```bash
go get github.com/zoobzio/herald/nats
go get github.com/nats-io/nats.go
```

### Usage

```go
import (
    natsgo "github.com/nats-io/nats.go"
    heraldnats "github.com/zoobzio/herald/nats"
)

// Create NATS connection
nc, _ := natsgo.Connect("nats://localhost:4222")
defer nc.Close()

// Create provider with adapters implementing the interfaces
provider := heraldnats.New("orders",
    heraldnats.WithConn(connAdapter{nc}),
    heraldnats.WithSubscriber(subAdapter{nc}),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithConn(c)` | Connection for publishing |
| `WithSubscriber(s)` | Subscriber for consuming |

### Metadata Mapping

NATS core does not support message headers. Metadata is ignored.

For header support, use NATS JetStream (requires different adapter).

### Notes

- Simple pub/sub model
- No persistence without JetStream
- Ack/Nack are no-ops for core NATS

---

## Google Pub/Sub

Managed messaging service for GCP.

### Installation

```bash
go get github.com/zoobzio/herald/pubsub
go get cloud.google.com/go/pubsub
```

### Usage

```go
import (
    "cloud.google.com/go/pubsub"
    heraldpubsub "github.com/zoobzio/herald/pubsub"
)

// Create GCP Pub/Sub client
client, _ := pubsub.NewClient(ctx, "my-project")
defer client.Close()

// Create provider with adapters
provider := heraldpubsub.New(
    heraldpubsub.WithTopic(topicAdapter{client.Topic("orders")}),
    heraldpubsub.WithSubscription(subAdapter{client.Subscription("orders-sub")}),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithTopic(t)` | Topic for publishing |
| `WithSubscription(s)` | Subscription for consuming |

### Metadata Mapping

```go
// Metadata maps to Pub/Sub attributes
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: msg.Attributes["correlation-id"] = "abc"
```

### Notes

- Requires GCP project and credentials
- Subscription must exist before consuming
- Ack confirms message, Nack triggers redelivery

---

## Redis Streams

In-memory data store with stream persistence.

### Installation

```bash
go get github.com/zoobzio/herald/redis
go get github.com/redis/go-redis/v9
```

### Usage

```go
import (
    "github.com/redis/go-redis/v9"
    heraldredis "github.com/zoobzio/herald/redis"
)

// Create Redis client
rdb := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})
defer rdb.Close()

// Create provider with adapter
provider := heraldredis.New("orders-stream",
    heraldredis.WithClient(clientAdapter{rdb}),
    heraldredis.WithGroup("order-group"),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithClient(c)` | Redis client adapter |
| `WithGroup(g)` | Consumer group name |

### Metadata Mapping

```go
// Metadata stored as additional stream fields
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: XADD stream * data "..." correlation-id "abc"
```

### Notes

- Uses Redis Streams with consumer groups
- Ack uses XACK, Nack leaves message pending
- Consumer group created automatically if needed

---

## AWS SQS

Managed message queuing service.

### Installation

```bash
go get github.com/zoobzio/herald/sqs
go get github.com/aws/aws-sdk-go-v2/service/sqs
```

### Usage

```go
import (
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/sqs"
    heraldsqs "github.com/zoobzio/herald/sqs"
)

// Create AWS config and SQS client
cfg, _ := config.LoadDefaultConfig(ctx)
sqsClient := sqs.NewFromConfig(cfg)

// Create provider with adapter
provider := heraldsqs.New(
    "https://sqs.us-east-1.amazonaws.com/123456789/orders",
    heraldsqs.WithClient(clientAdapter{sqsClient}),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithClient(c)` | SQS client adapter |

### Metadata Mapping

```go
// Metadata maps to SQS MessageAttributes
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: MessageAttributes["correlation-id"] = {DataType: "String", StringValue: "abc"}
```

### Notes

- Uses long polling for Subscribe
- Ack deletes message, Nack returns to queue after visibility timeout
- Supports FIFO queues (use `.fifo` suffix in queue name)

---

## RabbitMQ/AMQP

Traditional message broker using AMQP protocol.

### Installation

```bash
go get github.com/zoobzio/herald/amqp
go get github.com/rabbitmq/amqp091-go
```

### Usage

```go
import (
    amqp "github.com/rabbitmq/amqp091-go"
    heraldamqp "github.com/zoobzio/herald/amqp"
)

// Create AMQP connection and channel
conn, _ := amqp.Dial("amqp://guest:guest@localhost:5672/")
defer conn.Close()

ch, _ := conn.Channel()
defer ch.Close()

// Create provider with adapter
provider := heraldamqp.New("orders-queue",
    heraldamqp.WithChannel(channelAdapter{ch}),
    heraldamqp.WithExchange("orders-exchange"),
    heraldamqp.WithRoutingKey("order.created"),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithChannel(ch)` | AMQP channel adapter |
| `WithExchange(e)` | Exchange name for publishing |
| `WithRoutingKey(k)` | Routing key for publishing |

### Metadata Mapping

```go
// Metadata maps to AMQP headers
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: msg.Headers["correlation-id"] = "abc"
```

### Notes

- Creates exchange and queue if they don't exist
- Ack confirms, Nack requeues message
- Supports various exchange types (direct, fanout, topic, headers)

---

## AWS SNS

Pub/sub messaging for AWS (publish only).

### Installation

```bash
go get github.com/zoobzio/herald/sns
go get github.com/aws/aws-sdk-go-v2/service/sns
```

### Usage

```go
import (
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/sns"
    heraldsns "github.com/zoobzio/herald/sns"
)

// Create AWS config and SNS client
cfg, _ := config.LoadDefaultConfig(ctx)
snsClient := sns.NewFromConfig(cfg)

// Create provider
provider := heraldsns.New(
    "arn:aws:sns:us-east-1:123456789:orders",
    heraldsns.WithClient(clientAdapter{snsClient}),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithClient(c)` | SNS client adapter |

### Metadata Mapping

```go
// Metadata maps to SNS MessageAttributes
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: MessageAttributes["correlation-id"] = {DataType: "String", StringValue: "abc"}
```

### Notes

- **Publish only** - Subscribe returns closed channel
- Use with SQS subscription for consuming
- Supports FIFO topics

---

## SQL

Database-backed message queue.

### Installation

```bash
go get github.com/zoobzio/herald/sql
```

### Usage

```go
import (
    "database/sql"
    heraldsql "github.com/zoobzio/herald/sql"
    _ "github.com/lib/pq"
)

// Create database connection
db, _ := sql.Open("postgres", "postgres://localhost/mydb")
defer db.Close()

// Create provider with adapter
provider := heraldsql.New("orders",
    heraldsql.WithDB(dbAdapter{db}),
    heraldsql.WithPollInterval(500 * time.Millisecond),
    heraldsql.WithBatchSize(20),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithDB(db)` | Database adapter |
| `WithPollInterval(d)` | How often to poll (default: 100ms) |
| `WithBatchSize(n)` | Messages per poll (default: 10) |

### Metadata Mapping

```go
// Metadata stored in JSONB metadata column
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: INSERT ... metadata = '{"correlation-id": "abc"}'
```

### Notes

- Works with any database/sql compatible driver
- Ack updates status to 'processed', Nack to 'failed'
- Good for transactional consistency with application data

---

## BoltDB

Embedded key-value store for local queues.

### Installation

```bash
go get github.com/zoobzio/herald/bolt
go get go.etcd.io/bbolt
```

### Usage

```go
import (
    "go.etcd.io/bbolt"
    heraldbolt "github.com/zoobzio/herald/bolt"
)

// Create BoltDB
db, _ := bbolt.Open("mydb.bolt", 0600, nil)
defer db.Close()

// Create provider with adapter
provider := heraldbolt.New("orders",
    heraldbolt.WithDB(dbAdapter{db}),
    heraldbolt.WithPollInterval(100 * time.Millisecond),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithDB(db)` | BoltDB adapter |
| `WithPollInterval(d)` | How often to poll (default: 100ms) |
| `WithBatchSize(n)` | Messages per poll (default: 10) |

### Metadata Mapping

BoltDB does not support metadata. Metadata is ignored.

### Notes

- Embedded, no external dependencies
- Single-process only (file locked)
- Good for local development and testing
- Ack deletes message, Nack leaves it

---

## Firestore

Firebase/GCP document database.

### Installation

```bash
go get github.com/zoobzio/herald/firestore
go get cloud.google.com/go/firestore
```

### Usage

```go
import (
    "cloud.google.com/go/firestore"
    heraldfirestore "github.com/zoobzio/herald/firestore"
)

// Create Firestore client
client, _ := firestore.NewClient(ctx, "my-project")
defer client.Close()

// Create provider with adapter
provider := heraldfirestore.New("messages",
    heraldfirestore.WithClient(clientAdapter{client}),
)
defer provider.Close()
```

### Options

| Option | Description |
|--------|-------------|
| `WithClient(c)` | Firestore client adapter |

### Metadata Mapping

```go
// Metadata stored as document fields
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc",
})
// Becomes: doc.Set(ctx, map[string]any{"data": ..., "correlation-id": "abc"})
```

### Notes

- Uses Firestore snapshots for real-time updates
- Ack deletes document, Nack updates status field
- Good for Firebase applications

---

## io

Testing provider using io.Reader and io.Writer.

### Installation

Included in core package:
```bash
go get github.com/zoobzio/herald/io
```

### Usage

```go
import heraldio "github.com/zoobzio/herald/io"

// Reader for subscribing
provider := heraldio.New(heraldio.WithReader(strings.NewReader(`{"id":"1"}` + "\n")))

// Writer for publishing
var buf strings.Builder
provider := heraldio.New(heraldio.WithWriter(&buf))

// Combined (for in-memory testing)
pr, pw := io.Pipe()
provider := heraldio.New(
    heraldio.WithReader(pr),
    heraldio.WithWriter(pw),
)
```

### Options

| Option | Description |
|--------|-------------|
| `WithReader(r)` | io.Reader for consuming |
| `WithWriter(w)` | io.Writer for publishing |
| `WithDelimiter(d)` | Message delimiter (default: newline) |

### Metadata Mapping

io provider does not support metadata. Metadata is ignored.

### Notes

- **Testing only** - not for production
- Newline-delimited JSON by default
- Ack/Nack are no-ops
- Great for unit tests without external dependencies

---

## Provider Selection Guide

### By Use Case

| Use Case | Recommended Provider |
|----------|---------------------|
| High-throughput streaming | Kafka |
| Cloud-native microservices | Pub/Sub, SQS |
| Simple pub/sub | NATS |
| Traditional enterprise | RabbitMQ/AMQP |
| In-memory with persistence | Redis Streams |
| Transactional consistency | SQL |
| Local development | BoltDB, io |
| Firebase applications | Firestore |
| Fan-out to multiple consumers | SNS + SQS |

### By Feature

| Feature | Providers |
|---------|-----------|
| Metadata/Headers | Kafka, Pub/Sub, SQS, AMQP, SNS, Redis, SQL, Firestore |
| Consumer Groups | Kafka, Redis, SQS (via multiple consumers) |
| Dead Letter Queue | SQS (native), RabbitMQ (via config) |
| Ordering Guarantees | Kafka (per partition), SQS FIFO |
| At-Least-Once | All (with proper Ack usage) |

## Next Steps

- [Pipeline Options](./3.pipeline-options.md) - Add reliability with middleware
- [Metadata Guide](./4.metadata.md) - Header propagation patterns
- [Testing Guide](./1.testing.md) - Test your integrations
