---
title: Reliability
description: Pipeline options for resilient message bridging
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Guides
  - Reliability
  - Pipelines
---

# Reliability

Herald provides composable pipeline options for building resilient message bridges. These options wrap the publish/subscribe operations with retry logic, timeouts, circuit breakers, and rate limiting.

## Processing Hooks

Herald exposes pipz primitives for adding processing steps to the pipeline.

### WithApply

Transform data with possible failure:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithApply[Order]("validate", func(ctx context.Context, order Order) (Order, error) {
        if order.Total < 0 {
            return order, errors.New("invalid total")
        }
        return order, nil
    }),
})
```

### WithEffect

Side effects without modifying data:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithEffect[Order]("log", func(ctx context.Context, order Order) error {
        log.Printf("processing order %s", order.ID)
        return nil
    }),
})
```

### WithTransform

Pure transformation that cannot fail:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithTransform[Order]("timestamp", func(ctx context.Context, order Order) Order {
        order.ProcessedAt = time.Now()
        return order
    }),
})
```

### Error Behavior

Return an error to abort processing:
- **Publisher**: Error prevents publish, emits to `ErrorSignal`
- **Subscriber**: Error triggers `Nack()`, emits to `ErrorSignal`

### Wrapping Order

Options wrap inside-out. Later options wrap earlier ones:

```go
opts := []herald.Option[Order]{
    herald.WithEffect[Order]("inner", innerFn),  // runs second
    herald.WithEffect[Order]("outer", outerFn),  // runs first
}
```

Execution order: `outer → inner → terminal`

## Pipeline Options

### Retry

Retry failed operations immediately:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithRetry[Order](3), // Retry up to 3 times
})
```

Use for transient failures like network blips.

### Backoff

Retry with exponential backoff:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
    // Delays: 100ms, 200ms, 400ms
})
```

Use when the downstream system needs recovery time.

### Timeout

Cancel operations that take too long:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
})
```

Prevents hanging on slow brokers.

### Circuit Breaker

Stop attempting operations after repeated failures:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithCircuitBreaker[Order](5, 30*time.Second),
    // Opens after 5 failures, recovers after 30s
})
```

Prevents cascade failures when a broker is down.

### Rate Limit

Limit operations per second:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithRateLimit[Order](100, 10),
    // 100 ops/sec with burst of 10
})
```

Protects downstream systems from overload.

### Error Handler

Custom error handling via pipz chainable:

```go
import "github.com/zoobzio/pipz"

errorLogger := pipz.Effect("log-error", func(ctx context.Context, err *pipz.Error[Order]) error {
    log.Printf("publish failed: %v (order: %s)", err.Err, err.InputData.ID)
    metrics.IncrementPublishError()
    return nil
})

pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithErrorHandler[Order](errorLogger),
})
```

The error handler observes errors without modifying the error flow — the original error still propagates after the handler processes it.

### Custom Pipeline

Full control over the pipeline:

```go
import "github.com/zoobzio/pipz"

customPipeline := pipz.New(
    pipz.WithRetry[herald.PublishFunc[Order]](3),
    pipz.WithTimeout[herald.PublishFunc[Order]](5*time.Second),
)

pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithPipeline[Order](customPipeline),
})
```

## Combining Options

Options are applied in order, wrapping inside-out:

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithRateLimit[Order](100, 10),    // Outermost: rate limit first
    herald.WithCircuitBreaker[Order](5, 30*time.Second),
    herald.WithBackoff[Order](3, 100*time.Millisecond),
    herald.WithTimeout[Order](5*time.Second), // Innermost: timeout per attempt
})
```

Execution order:
1. Rate limit (wait if needed)
2. Check circuit breaker (fail fast if open)
3. Attempt with backoff (retry on failure)
4. Each attempt has 5s timeout

## Recommended Patterns

### High-Availability Publishing

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithBackoff[Order](5, 200*time.Millisecond),
    herald.WithTimeout[Order](10*time.Second),
    herald.WithCircuitBreaker[Order](10, time.Minute),
})
```

### Rate-Limited Subscription

```go
sub := herald.NewSubscriber(provider, signal, key, []herald.Option[Order]{
    herald.WithRateLimit[Order](50, 5),
    herald.WithTimeout[Order](30*time.Second),
})
```

### Fail-Fast for Critical Paths

```go
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithTimeout[Order](time.Second),
    // No retry - fail immediately for latency-sensitive operations
})
```

## Error Propagation

When all retries are exhausted or the circuit is open, errors propagate to capitan:

```go
capitan.Hook(herald.ErrorSignal, func(ctx context.Context, e *capitan.Event) {
    err, _ := herald.ErrorKey.From(e)

    switch {
    case errors.Is(err.Err, pipz.ErrCircuitOpen):
        alertOps("Circuit breaker open for " + err.Signal)
    case errors.Is(err.Err, context.DeadlineExceeded):
        log.Printf("Timeout publishing to %s", err.Signal)
    default:
        log.Printf("Publish failed: %v", err.Err)
    }
})
```

## Performance Considerations

Pipeline options add minimal overhead:
- **Retry/Backoff**: Only active on failures
- **Timeout**: Single context wrapper
- **Circuit Breaker**: Atomic counter check
- **Rate Limit**: Token bucket algorithm

For maximum throughput, use options sparingly:

```go
// High-throughput path: minimal options
pub := herald.NewPublisher(provider, signal, key, nil)

// Critical path: full protection
pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithRetry[Order](3),
    herald.WithTimeout[Order](5*time.Second),
})
```

## Integration with pipz

Herald's options are powered by [pipz](https://github.com/zoobzio/pipz). For advanced use cases, use pipz directly:

```go
import "github.com/zoobzio/pipz"

pipeline := pipz.New(
    pipz.WithRetry[herald.PublishFunc[Order]](3),
    pipz.WithBulkhead[herald.PublishFunc[Order]](10), // Concurrent limit
    pipz.WithFallback[herald.PublishFunc[Order]](fallbackPublish),
)

pub := herald.NewPublisher(provider, signal, key, []herald.Option[Order]{
    herald.WithPipeline[Order](pipeline),
})
```
