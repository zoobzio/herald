---
title: Pipeline Options
description: Timeout, backoff, rate limiting, and custom pipelines.
author: Herald Team
published: 2025-12-06
tags: [Guide, Pipeline, Middleware]
---

# Pipeline Options

Pipeline options wrap publish/subscribe operations with reliability patterns. They compose via [pipz](https://github.com/zoobzio/pipz).

## Overview

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithBackoff[Order](3, 100*time.Millisecond),
    herald.WithRateLimit[Order](100, 10),
}

pub := herald.NewPublisher(provider, signal, key, opts)
sub := herald.NewSubscriber(provider, signal, key, opts)
```

Options wrap from **outside in**:

```
┌─────────────────────────────────────────────────────────┐
│ Timeout (5s)                                             │
│   ┌─────────────────────────────────────────────────┐   │
│   │ Backoff (3 attempts)                             │   │
│   │   ┌─────────────────────────────────────────┐   │   │
│   │   │ RateLimit (100/sec)                      │   │   │
│   │   │   ┌─────────────────────────────────┐   │   │   │
│   │   │   │ Terminal (publish or emit)      │   │   │   │
│   │   │   └─────────────────────────────────┘   │   │   │
│   │   └─────────────────────────────────────────┘   │   │
│   └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## WithTimeout

Enforces a maximum duration for the operation.

### Signature

```go
func WithTimeout[T any](duration time.Duration) Option[T]
```

### Usage

```go
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
}
```

### Behavior

```
Operation started
       │
       ├──────────────────────────────┐
       │                              │
       ▼                              ▼
  Operation runs              Timer (5s)
       │                              │
       │                              │
   ┌───┴───┐                    ┌─────┴─────┐
   │       │                    │           │
Success  Error               Timeout     (waiting)
   │       │                    │
   ▼       ▼                    ▼
 Return  Return           context.DeadlineExceeded
```

### When to Use

- External API calls with unpredictable latency
- Preventing hung operations from blocking the pipeline
- Enforcing SLAs on processing time

### Considerations

- Timeout applies to the entire wrapped operation
- If combined with Backoff, timeout applies to all retries combined
- Context cancellation is respected

### Example

```go
// Timeout publish operations at 5 seconds
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
}

pub := herald.NewPublisher(provider, signal, key, opts)
pub.Start(ctx)

// If publish takes > 5s, operation fails with context.DeadlineExceeded
capitan.Emit(ctx, signal, key.Field(order))
```

---

## WithBackoff

Retries failed operations with exponential backoff.

### Signature

```go
func WithBackoff[T any](maxAttempts int, baseDelay time.Duration) Option[T]
```

### Usage

```go
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}
```

### Behavior

```
Attempt 1 ──[fail]──► wait 100ms ──┐
                                    ▼
Attempt 2 ──[fail]──► wait 200ms ──┐
                                    ▼
Attempt 3 ──[fail]──► Return error (no more attempts)

Or:

Attempt 1 ──[fail]──► wait 100ms ──┐
                                    ▼
Attempt 2 ──[success]──► Return success
```

### Delay Progression

| Attempt | Delay |
|---------|-------|
| 1 | (immediate) |
| 2 | 100ms |
| 3 | 200ms |
| 4 | 400ms |
| 5 | 800ms |

Delay = baseDelay × 2^(attempt-2)

### When to Use

- Transient failures (network blips, temporary unavailability)
- External service rate limiting
- Database connection issues

### Considerations

- Total time = processing time + all delays
- With 5 attempts and 100ms base: max delay = 100 + 200 + 400 + 800 = 1.5s
- Context cancellation stops retries

### Example

```go
// Retry up to 3 times with exponential backoff
opts := []herald.Option[Order]{
    herald.WithBackoff[Order](3, 100*time.Millisecond),
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

### Combined with Timeout

```go
// Total operation (including all retries) must complete in 5s
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
    herald.WithBackoff[Order](3, 500*time.Millisecond),
}
```

---

## WithRateLimit

Controls throughput using token bucket rate limiting.

### Signature

```go
func WithRateLimit[T any](rate float64, burst int) Option[T]
```

### Parameters

| Parameter | Description |
|-----------|-------------|
| `rate` | Operations per second |
| `burst` | Maximum burst size (tokens available immediately) |

### Usage

```go
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](100, 10), // 100/sec, burst of 10
}
```

### Behavior

```
┌──────────────────────────────────────────────────────────────────┐
│                      Token Bucket                                 │
│                                                                   │
│   Bucket: [●][●][●][●][●][○][○][○][○][○]  (5/10 tokens)         │
│                                                                   │
│   Rate: 100 tokens/second (1 token every 10ms)                   │
│   Burst: 10 tokens max                                           │
│                                                                   │
│   Operation requests token:                                       │
│   - Token available → proceed immediately                        │
│   - No token → wait until token added                            │
└──────────────────────────────────────────────────────────────────┘
```

### When to Use

- Protecting downstream services from overload
- Respecting external API rate limits
- Smoothing burst traffic

### Considerations

- Operations wait for tokens (blocking)
- Burst allows handling temporary spikes
- Rate limiting is per-publisher/subscriber instance

### Example

```go
// Limit to 50 operations per second
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](50, 5),
}

sub := herald.NewSubscriber(provider, signal, key, opts)
```

### Subscriber Rate Limiting

Rate limiting on subscribers controls how fast messages are emitted to capitan:

```go
// Process max 10 messages per second
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](10, 2),
}

sub := herald.NewSubscriber(provider, signal, key, opts)
// Messages wait in provider's buffer if rate limited
```

---

## WithPipeline

Adds custom pipz middleware to the pipeline.

### Signature

```go
func WithPipeline[T any](p pipz.Chainable[T]) Option[T]
```

### Usage

```go
import "github.com/zoobzio/pipz"

custom := pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.Total <= 0 {
        return o, errors.New("invalid total")
    }
    return o, nil
})

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](custom),
}
```

### Custom Middleware Examples

#### Validation

```go
validate := pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.ID == "" {
        return o, errors.New("order ID required")
    }
    if len(o.Items) == 0 {
        return o, errors.New("order must have items")
    }
    return o, nil
})

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](validate),
}
```

#### Enrichment

```go
enrich := pipz.Transform("enrich", func(ctx context.Context, o Order) Order {
    o.ProcessedAt = time.Now()
    o.ProcessedBy = "order-service"
    return o
})

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](enrich),
}
```

#### Logging

```go
logOrder := pipz.Effect("log", func(ctx context.Context, o Order) error {
    log.Printf("Processing order: %s", o.ID)
    return nil
})

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](logOrder),
}
```

#### Circuit Breaker

```go
import "github.com/zoobzio/pipz"

// Create circuit breaker for external API
apiCall := pipz.Apply("api", func(ctx context.Context, o Order) (Order, error) {
    return externalAPI.Process(ctx, o)
})

circuitBreaker := pipz.NewCircuitBreaker("api-circuit", apiCall, 5, time.Minute)

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](circuitBreaker),
}
```

#### Sequence of Middleware

```go
pipeline := pipz.NewSequence("order-pipeline",
    pipz.Apply("validate", validateOrder),
    pipz.Transform("enrich", enrichOrder),
    pipz.Effect("log", logOrder),
)

opts := []herald.Option[Order]{
    herald.WithPipeline[Order](pipeline),
}
```

---

## Combining Options

Options compose in the order specified:

```go
opts := []herald.Option[Order]{
    // 1. Outer: Overall timeout
    herald.WithTimeout[Order](10 * time.Second),

    // 2. Retry transient failures
    herald.WithBackoff[Order](3, 200*time.Millisecond),

    // 3. Rate limit
    herald.WithRateLimit[Order](100, 20),

    // 4. Custom validation
    herald.WithPipeline[Order](validate),
}
```

Execution flow:

```
1. Timeout starts (10s timer)
   │
2. Backoff wrapper
   │
   ├── Attempt 1
   │   │
   │   3. RateLimit (wait for token)
   │      │
   │      4. Validate
   │         │
   │         5. Publish/Emit (terminal)
   │         │
   │      ◄──┘ Error?
   │      │
   │   ◄──┘ Wait 200ms, retry
   │
   ├── Attempt 2...
   │
   └── Attempt 3...
       │
◄──────┘ Success or final failure
```

---

## Publisher vs Subscriber Pipelines

### Publisher Pipeline

Wraps the **publish operation**:

```go
// Pipeline wraps: json.Marshal + provider.Publish
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](5 * time.Second),
}

pub := herald.NewPublisher(provider, signal, key, opts)
```

Errors in the pipeline:
- Logged but not propagated (capitan hooks are fire-and-forget)
- Use pipeline error handlers for visibility

### Subscriber Pipeline

Wraps the **emit operation**:

```go
// Pipeline wraps: capitan.Emit
opts := []herald.Option[Order]{
    herald.WithRateLimit[Order](50, 10),
}

sub := herald.NewSubscriber(provider, signal, key, opts)
```

Errors in the pipeline:
- Trigger Nack (message redelivery)
- Validation errors → Nack → redelivery → validation fails again (careful!)

### Validation in Subscribers

For validation that should reject bad messages permanently:

```go
validate := pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.ID == "" {
        // Log and return success to Ack the bad message
        log.Warn("Invalid order - no ID, dropping")
        return o, nil // Will Ack
    }
    return o, nil
})
```

Or handle in the capitan hook:

```go
capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    order, ok := key.From(e)
    if !ok || order.ID == "" {
        log.Warn("Invalid order, ignoring")
        return // Message already Ack'd at this point
    }
    processOrder(order)
})
```

---

## Performance Considerations

### Timeout

- Minimal overhead (timer allocation)
- Use reasonable timeouts (not too short)

### Backoff

- Sleep uses time.Sleep (blocks goroutine)
- Memory: O(1) per operation

### RateLimit

- Uses token bucket algorithm
- Memory: O(1) per rate limiter
- Blocking wait for tokens

### Custom Pipeline

- Depends on your middleware complexity
- Profile in production

---

## Best Practices

### 1. Order Matters

```go
// ✅ Good: Timeout outside, specific handling inside
opts := []herald.Option[Order]{
    herald.WithTimeout[Order](30 * time.Second),
    herald.WithBackoff[Order](3, 500*time.Millisecond),
    herald.WithRateLimit[Order](100, 20),
}

// ❌ Bad: Rate limit outside timeout
// (rate limiting still applies even if timeout fires)
```

### 2. Calculate Total Time

With Backoff(3, 500ms):
- Delays: 500ms + 1000ms = 1.5s
- Plus processing time per attempt
- Timeout should exceed this

### 3. Match to Failure Modes

- **Transient (network)**: Backoff with short delays
- **Overload**: Rate limit + longer backoff
- **Timeout**: Match to expected latency + buffer

### 4. Monitor Pipeline Errors

```go
// Use pipz error handling
pipeline := pipz.NewSequence("monitored",
    pipz.Handle("errors",
        yourProcessor,
        pipz.Effect("log-error", func(ctx context.Context, err error) error {
            metrics.Inc("pipeline_errors")
            return err
        }),
    ),
)
```

## Next Steps

- [Metadata Guide](./4.metadata.md) - Header propagation
- [Best Practices](./5.best-practices.md) - Production patterns
- [pipz Documentation](https://github.com/zoobzio/pipz) - Full middleware reference
