---
title: Metadata
description: Header propagation patterns across message brokers.
author: Herald Team
published: 2025-12-06
tags: [Guide, Metadata, Headers]
---

# Metadata

Metadata enables header propagation across message brokers for cross-cutting concerns like correlation IDs, tracing, and routing hints.

## Overview

```go
// Attach metadata to context
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc-123",
    "trace-id":       "xyz-789",
})

// Emit event - metadata flows to broker
capitan.Emit(ctx, signal, key.Field(order))

// On receive - metadata extracted from context
capitan.Hook(signal, func(ctx context.Context, e *capitan.Event) {
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]
})
```

## The Metadata Type

```go
type Metadata map[string]string
```

Metadata is a simple string-to-string map. This ensures compatibility across all brokers (all support string headers).

## Context Functions

### ContextWithMetadata

Attaches metadata to a context:

```go
func ContextWithMetadata(ctx context.Context, m Metadata) context.Context
```

```go
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "key": "value",
})
```

### MetadataFromContext

Extracts metadata from a context:

```go
func MetadataFromContext(ctx context.Context) Metadata
```

```go
meta := herald.MetadataFromContext(ctx)
if meta != nil {
    value := meta["key"]
}
```

Returns `nil` if no metadata present.

## Publish Flow

When publishing, metadata flows from context to broker:

```
┌─────────────────────────────────────────────────────────────────┐
│                       Publish Flow                               │
└─────────────────────────────────────────────────────────────────┘

Application:
    ctx := herald.ContextWithMetadata(ctx, Metadata{
        "correlation-id": "abc-123",
    })
    capitan.Emit(ctx, signal, key.Field(order))
         │
         ▼
Publisher:
    metadata := MetadataFromContext(ctx)
    provider.Publish(ctx, data, metadata)
         │
         ▼
Provider (e.g., Kafka):
    msg.Headers = []kafka.Header{
        {Key: "correlation-id", Value: []byte("abc-123")},
    }
    writer.WriteMessages(ctx, msg)
         │
         ▼
Broker:
    Message stored with headers
```

## Subscribe Flow

When subscribing, metadata flows from broker to context:

```
┌─────────────────────────────────────────────────────────────────┐
│                      Subscribe Flow                              │
└─────────────────────────────────────────────────────────────────┘

Broker:
    Message with headers
         │
         ▼
Provider (e.g., Kafka):
    for _, h := range msg.Headers {
        metadata[h.Key] = string(h.Value)
    }
    return Message{Data: msg.Value, Metadata: metadata, ...}
         │
         ▼
Subscriber:
    if msg.Metadata != nil {
        ctx = ContextWithMetadata(ctx, msg.Metadata)
    }
    capitan.Emit(ctx, signal, key.Field(value))
         │
         ▼
Handler:
    capitan.Hook(signal, func(ctx context.Context, e *Event) {
        meta := MetadataFromContext(ctx)
        correlationID := meta["correlation-id"]
    })
```

## Broker Mapping

Each provider maps metadata to its native header format:

### Kafka

```go
// Outbound
msg.Headers = []kafka.Header{
    {Key: "key", Value: []byte("value")},
}

// Inbound
for _, h := range msg.Headers {
    metadata[h.Key] = string(h.Value)
}
```

### AWS SQS

```go
// Outbound
input.MessageAttributes = map[string]*sqs.MessageAttributeValue{
    "key": {
        DataType:    aws.String("String"),
        StringValue: aws.String("value"),
    },
}

// Inbound
for k, v := range msg.MessageAttributes {
    metadata[k] = *v.StringValue
}
```

### Google Pub/Sub

```go
// Outbound
msg.Attributes = map[string]string{
    "key": "value",
}

// Inbound
metadata = msg.Attributes
```

### RabbitMQ/AMQP

```go
// Outbound
msg.Headers = amqp.Table{
    "key": "value",
}

// Inbound
for k, v := range msg.Headers {
    metadata[k] = v.(string)
}
```

### Redis Streams

```go
// Outbound (as additional fields)
args := &redis.XAddArgs{
    Stream: stream,
    Values: map[string]any{
        "data": data,
        "key":  "value", // metadata as fields
    },
}

// Inbound
for k, v := range msg.Values {
    if k != "data" {
        metadata[k] = v.(string)
    }
}
```

### SQL

```go
// Outbound
INSERT INTO messages (data, metadata) VALUES ($1, $2)
// metadata stored as JSON

// Inbound
json.Unmarshal(row.metadata, &metadata)
```

### Providers Without Support

These providers ignore metadata:

| Provider | Reason |
|----------|--------|
| NATS (core) | No header support in core protocol |
| BoltDB | Key-value store, no native headers |
| io | Simple streams, no header concept |

## Common Patterns

### Correlation ID

Track a request across services:

```go
// Service A: Generate correlation ID
correlationID := uuid.New().String()
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": correlationID,
})
capitan.Emit(ctx, orderCreated, key.Field(order))

// Service B: Propagate correlation ID
capitan.Hook(orderReceived, func(ctx context.Context, e *capitan.Event) {
    meta := herald.MetadataFromContext(ctx)
    correlationID := meta["correlation-id"]

    // Include in logs
    log.WithField("correlation-id", correlationID).Info("Processing order")

    // Propagate to downstream calls
    ctx = herald.ContextWithMetadata(ctx, herald.Metadata{
        "correlation-id": correlationID,
    })
    capitan.Emit(ctx, shipmentCreated, key.Field(shipment))
})
```

### Distributed Tracing

Propagate trace context:

```go
// Extract trace context from incoming request
traceID := r.Header.Get("X-Trace-ID")
spanID := r.Header.Get("X-Span-ID")

ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "trace-id": traceID,
    "span-id":  spanID,
})

capitan.Emit(ctx, signal, key.Field(value))
```

With OpenTelemetry (via shotel):

```go
// shotel extracts trace context from capitan events
// Metadata correlation-id can be used for span correlation
```

### Source Identification

Track message origin:

```go
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "source-service": "order-api",
    "source-version": "v1.2.3",
    "source-host":    hostname,
})

capitan.Emit(ctx, signal, key.Field(value))
```

### Content Type

Indicate serialization format:

```go
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "content-type": "application/json",
    "encoding":     "utf-8",
})

capitan.Emit(ctx, signal, key.Field(value))
```

### Routing Hints

Guide message routing:

```go
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "priority":  "high",
    "tenant-id": tenantID,
    "region":    "us-east-1",
})

capitan.Emit(ctx, signal, key.Field(value))
```

## Cross-Service Propagation

In a multi-service architecture, propagate metadata across hops:

```
Service A                Service B                Service C
    │                        │                        │
    │ correlation-id: abc    │                        │
    ├───────────────────────►│                        │
    │                        │ correlation-id: abc    │
    │                        ├───────────────────────►│
    │                        │                        │
```

```go
// Helper function for propagation
func propagateMetadata(ctx context.Context) context.Context {
    meta := herald.MetadataFromContext(ctx)
    if meta == nil {
        return ctx
    }

    // Select keys to propagate
    propagated := herald.Metadata{}
    for _, key := range []string{"correlation-id", "trace-id", "tenant-id"} {
        if v, ok := meta[key]; ok {
            propagated[key] = v
        }
    }

    return herald.ContextWithMetadata(ctx, propagated)
}

// Usage
capitan.Hook(orderReceived, func(ctx context.Context, e *capitan.Event) {
    // Process order...

    // Propagate metadata to downstream emit
    ctx = propagateMetadata(ctx)
    capitan.Emit(ctx, shipmentCreated, key.Field(shipment))
})
```

## Merging Metadata

Add new metadata while preserving existing:

```go
func mergeMetadata(ctx context.Context, additional herald.Metadata) context.Context {
    existing := herald.MetadataFromContext(ctx)
    if existing == nil {
        return herald.ContextWithMetadata(ctx, additional)
    }

    merged := make(herald.Metadata, len(existing)+len(additional))
    for k, v := range existing {
        merged[k] = v
    }
    for k, v := range additional {
        merged[k] = v // Additional overwrites existing
    }

    return herald.ContextWithMetadata(ctx, merged)
}

// Usage
ctx = mergeMetadata(ctx, herald.Metadata{
    "processed-by": "order-service",
    "processed-at": time.Now().Format(time.RFC3339),
})
```

## Best Practices

### 1. Use Consistent Key Names

```go
// ✅ Good: Consistent naming
const (
    MetaCorrelationID = "correlation-id"
    MetaTraceID       = "trace-id"
    MetaTenantID      = "tenant-id"
)

ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    MetaCorrelationID: id,
})
```

### 2. Keep Metadata Small

```go
// ✅ Good: Small, essential data
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "correlation-id": "abc-123",
})

// ❌ Bad: Large data in metadata
ctx := herald.ContextWithMetadata(ctx, herald.Metadata{
    "full-request-body": largeJSON, // Don't do this
})
```

### 3. Handle Missing Metadata

```go
meta := herald.MetadataFromContext(ctx)
if meta == nil {
    // No metadata present
    return
}

correlationID := meta["correlation-id"]
if correlationID == "" {
    // Key not present, use default
    correlationID = generateID()
}
```

### 4. Document Expected Metadata

```go
// Package events documents expected metadata keys
//
// Metadata keys used across services:
//   - correlation-id: Request correlation identifier
//   - trace-id: Distributed trace identifier
//   - tenant-id: Multi-tenant identifier
//   - source-service: Originating service name
```

## Next Steps

- [Best Practices](./5.best-practices.md) - Production patterns
- [Providers Guide](./2.providers.md) - Provider-specific details
- [shotel Integration](https://github.com/zoobzio/shotel) - Observability with metadata
