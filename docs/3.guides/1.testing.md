---
title: Testing
description: Testing patterns with the io provider and mocks.
author: Herald Team
published: 2025-12-06
tags: [Guide, Testing, Mocks]
---

# Testing

This guide covers testing patterns for herald integrations.

## The io Provider

The `io` provider enables testing without real brokers by using `io.Reader` and `io.Writer`:

```go
import heraldio "github.com/zoobzio/herald/io"

// Read messages from a string
reader := heraldio.New(heraldio.WithReader(strings.NewReader(`{"id":"1"}` + "\n")))

// Write messages to a buffer
var buf strings.Builder
writer := heraldio.New(heraldio.WithWriter(&buf))
```

## Testing Publishers

### Basic Publisher Test

```go
func TestPublisher_PublishesOrder(t *testing.T) {
    ctx := context.Background()

    // Capture output
    var buf strings.Builder
    provider := heraldio.New(heraldio.WithWriter(&buf))

    // Create isolated capitan
    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.order", "Test order")
    key := capitan.NewKey[Order]("order", "test.Order")

    // Create and start publisher
    pub := herald.NewPublisher(provider, signal, key, nil,
        herald.WithPublisherCapitan[Order](c),
    )
    pub.Start(ctx)

    // Emit event
    c.Emit(ctx, signal, key.Field(Order{ID: "ORD-1", Total: 99.99}))

    // Drain and close
    c.Shutdown()
    pub.Close()

    // Verify output
    var published Order
    if err := json.Unmarshal([]byte(strings.TrimSpace(buf.String())), &published); err != nil {
        t.Fatalf("Failed to unmarshal: %v", err)
    }

    if published.ID != "ORD-1" {
        t.Errorf("Expected ID 'ORD-1', got %q", published.ID)
    }
}
```

### Testing Pipeline Options

```go
func TestPublisher_WithTimeout(t *testing.T) {
    ctx := context.Background()

    // Create a slow writer that blocks
    slowWriter := &slowWriter{delay: 100 * time.Millisecond}
    provider := heraldio.New(heraldio.WithWriter(slowWriter))

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.timeout", "Test timeout")
    key := capitan.NewKey[Order]("order", "test.Order")

    // Very short timeout
    opts := []herald.Option[Order]{
        herald.WithTimeout[Order](10 * time.Millisecond),
    }

    pub := herald.NewPublisher(provider, signal, key, opts,
        herald.WithPublisherCapitan[Order](c),
    )
    pub.Start(ctx)

    start := time.Now()
    c.Emit(ctx, signal, key.Field(Order{ID: "timeout-test"}))
    c.Shutdown()
    pub.Close()

    elapsed := time.Since(start)

    // Should timeout quickly, not wait for slow writer
    if elapsed > 50*time.Millisecond {
        t.Errorf("Expected timeout within 50ms, took %v", elapsed)
    }
}

type slowWriter struct {
    delay time.Duration
}

func (w *slowWriter) Write(p []byte) (int, error) {
    time.Sleep(w.delay)
    return len(p), nil
}
```

## Testing Subscribers

### Basic Subscriber Test

```go
func TestSubscriber_ReceivesMessage(t *testing.T) {
    ctx := context.Background()

    // Input message
    input := `{"id":"ORD-1","total":99.99}` + "\n"
    provider := heraldio.New(heraldio.WithReader(strings.NewReader(input)))

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.received", "Test received")
    key := capitan.NewKey[Order]("order", "test.Order")

    // Track received events
    var received Order
    var wg sync.WaitGroup
    wg.Add(1)

    c.Hook(signal, func(ctx context.Context, e *capitan.Event) {
        order, ok := key.From(e)
        if ok {
            received = order
            wg.Done()
        }
    })

    // Create and start subscriber
    sub := herald.NewSubscriber(provider, signal, key, nil,
        herald.WithSubscriberCapitan[Order](c),
    )
    sub.Start(ctx)

    // Wait for message
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(time.Second):
        t.Fatal("Timeout waiting for message")
    }

    sub.Close()

    if received.ID != "ORD-1" {
        t.Errorf("Expected ID 'ORD-1', got %q", received.ID)
    }
}
```

### Testing Multiple Messages

```go
func TestSubscriber_MultipleMessages(t *testing.T) {
    ctx := context.Background()

    // Multiple messages
    input := strings.Join([]string{
        `{"id":"1","total":10.00}`,
        `{"id":"2","total":20.00}`,
        `{"id":"3","total":30.00}`,
    }, "\n") + "\n"

    provider := heraldio.New(heraldio.WithReader(strings.NewReader(input)))

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.multi", "Test multi")
    key := capitan.NewKey[Order]("order", "test.Order")

    var received []Order
    var mu sync.Mutex
    var wg sync.WaitGroup
    wg.Add(3)

    c.Hook(signal, func(ctx context.Context, e *capitan.Event) {
        order, ok := key.From(e)
        if ok {
            mu.Lock()
            received = append(received, order)
            mu.Unlock()
            wg.Done()
        }
    })

    sub := herald.NewSubscriber(provider, signal, key, nil,
        herald.WithSubscriberCapitan[Order](c),
    )
    sub.Start(ctx)

    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(time.Second):
        t.Fatal("Timeout waiting for messages")
    }

    sub.Close()

    if len(received) != 3 {
        t.Fatalf("Expected 3 messages, got %d", len(received))
    }
}
```

### Testing Invalid JSON

```go
func TestSubscriber_InvalidJSON(t *testing.T) {
    ctx := context.Background()

    // Invalid JSON followed by valid
    input := "not json\n" + `{"id":"valid"}` + "\n"
    provider := heraldio.New(heraldio.WithReader(strings.NewReader(input)))

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.invalid", "Test invalid")
    key := capitan.NewKey[Order]("order", "test.Order")

    var received []Order
    var mu sync.Mutex
    var wg sync.WaitGroup
    wg.Add(1) // Only expect valid message

    c.Hook(signal, func(ctx context.Context, e *capitan.Event) {
        order, ok := key.From(e)
        if ok {
            mu.Lock()
            received = append(received, order)
            mu.Unlock()
            wg.Done()
        }
    })

    sub := herald.NewSubscriber(provider, signal, key, nil,
        herald.WithSubscriberCapitan[Order](c),
    )
    sub.Start(ctx)

    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(time.Second):
        t.Fatal("Timeout")
    }

    sub.Close()

    // Only valid message received
    if len(received) != 1 {
        t.Fatalf("Expected 1 message, got %d", len(received))
    }

    if received[0].ID != "valid" {
        t.Errorf("Expected ID 'valid', got %q", received[0].ID)
    }
}
```

## Testing Metadata

```go
func TestMetadata_Propagation(t *testing.T) {
    ctx := context.Background()

    var buf strings.Builder
    provider := heraldio.New(heraldio.WithWriter(&buf))

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.meta", "Test meta")
    key := capitan.NewKey[Order]("order", "test.Order")

    pub := herald.NewPublisher(provider, signal, key, nil,
        herald.WithPublisherCapitan[Order](c),
    )
    pub.Start(ctx)

    // Attach metadata
    ctx = herald.ContextWithMetadata(ctx, herald.Metadata{
        "correlation-id": "test-123",
        "source":         "unit-test",
    })

    c.Emit(ctx, signal, key.Field(Order{ID: "meta-test"}))

    c.Shutdown()
    pub.Close()

    // Note: io provider doesn't preserve metadata (no native header support)
    // For metadata tests, use a mock provider that captures metadata
}

func TestMetadata_SubscriberExtraction(t *testing.T) {
    ctx := context.Background()

    input := `{"id":"1"}` + "\n"
    provider := &mockProviderWithMetadata{
        reader: strings.NewReader(input),
        metadata: herald.Metadata{
            "correlation-id": "abc-123",
        },
    }

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.meta.sub", "Test meta sub")
    key := capitan.NewKey[Order]("order", "test.Order")

    var receivedMeta herald.Metadata
    var wg sync.WaitGroup
    wg.Add(1)

    c.Hook(signal, func(ctx context.Context, e *capitan.Event) {
        receivedMeta = herald.MetadataFromContext(ctx)
        wg.Done()
    })

    sub := herald.NewSubscriber(provider, signal, key, nil,
        herald.WithSubscriberCapitan[Order](c),
    )
    sub.Start(ctx)

    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(time.Second):
        t.Fatal("Timeout")
    }

    sub.Close()

    if receivedMeta["correlation-id"] != "abc-123" {
        t.Errorf("Expected correlation-id 'abc-123', got %q", receivedMeta["correlation-id"])
    }
}
```

## Mock Providers

For more control, create mock providers:

```go
type mockProvider struct {
    mu        sync.Mutex
    published []publishedMsg
    messages  chan herald.Result[herald.Message]
    closed    bool
}

type publishedMsg struct {
    data     []byte
    metadata herald.Metadata
}

func newMockProvider() *mockProvider {
    return &mockProvider{
        messages: make(chan herald.Result[herald.Message], 10),
    }
}

func (m *mockProvider) Publish(ctx context.Context, data []byte, metadata herald.Metadata) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.published = append(m.published, publishedMsg{data: data, metadata: metadata})
    return nil
}

func (m *mockProvider) Subscribe(ctx context.Context) <-chan herald.Result[herald.Message] {
    return m.messages
}

func (m *mockProvider) Close() error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.closed = true
    close(m.messages)
    return nil
}

// Helper to send test messages
func (m *mockProvider) Send(msg herald.Message) {
    m.messages <- herald.NewSuccess(msg)
}

func (m *mockProvider) SendError(err error) {
    m.messages <- herald.NewError[herald.Message](err)
}

// Helper to check published messages
func (m *mockProvider) Published() []publishedMsg {
    m.mu.Lock()
    defer m.mu.Unlock()
    return m.published
}
```

### Using Mock Provider

```go
func TestWithMockProvider(t *testing.T) {
    ctx := context.Background()

    provider := newMockProvider()

    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    signal := capitan.NewSignal("test.mock", "Test mock")
    key := capitan.NewKey[Order]("order", "test.Order")

    pub := herald.NewPublisher(provider, signal, key, nil,
        herald.WithPublisherCapitan[Order](c),
    )
    pub.Start(ctx)

    // Emit with metadata
    ctx = herald.ContextWithMetadata(ctx, herald.Metadata{
        "trace-id": "xyz",
    })
    c.Emit(ctx, signal, key.Field(Order{ID: "mock-test", Total: 50.00}))

    c.Shutdown()
    pub.Close()

    // Verify
    published := provider.Published()
    if len(published) != 1 {
        t.Fatalf("Expected 1 published, got %d", len(published))
    }

    // Check metadata was passed
    if published[0].metadata["trace-id"] != "xyz" {
        t.Errorf("Expected trace-id 'xyz', got %q", published[0].metadata["trace-id"])
    }

    // Check data
    var order Order
    json.Unmarshal(published[0].data, &order)
    if order.ID != "mock-test" {
        t.Errorf("Expected ID 'mock-test', got %q", order.ID)
    }
}
```

## Integration Tests

For integration tests with real brokers, use build tags:

```go
//go:build integration
// +build integration

package integration

import (
    "testing"
    kafkago "github.com/segmentio/kafka-go"
    "github.com/zoobzio/herald/kafka"
)

func TestKafkaIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    // Create kafka-go writer/reader
    writer := &kafkago.Writer{
        Addr:  kafkago.TCP("localhost:9092"),
        Topic: "test-topic",
    }
    defer writer.Close()

    provider := kafka.New("test-topic",
        kafka.WithWriter(writer),
    )
    defer provider.Close()

    // ... test with real Kafka ...
}
```

Run with:
```bash
go test -tags=integration ./...
```

## Test Helpers

Create reusable test helpers:

```go
package testutil

import (
    "context"
    "sync"
    "testing"
    "time"

    "github.com/zoobzio/capitan"
    "github.com/zoobzio/herald"
)

// EventCapture captures events for testing
type EventCapture[T any] struct {
    mu     sync.Mutex
    events []T
    wg     sync.WaitGroup
}

func NewEventCapture[T any](count int) *EventCapture[T] {
    ec := &EventCapture[T]{}
    ec.wg.Add(count)
    return ec
}

func (ec *EventCapture[T]) Handler(key capitan.GenericKey[T]) func(context.Context, *capitan.Event) {
    return func(ctx context.Context, e *capitan.Event) {
        value, ok := key.From(e)
        if ok {
            ec.mu.Lock()
            ec.events = append(ec.events, value)
            ec.mu.Unlock()
            ec.wg.Done()
        }
    }
}

func (ec *EventCapture[T]) Wait(t *testing.T, timeout time.Duration) {
    done := make(chan struct{})
    go func() {
        ec.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
    case <-time.After(timeout):
        t.Fatal("Timeout waiting for events")
    }
}

func (ec *EventCapture[T]) Events() []T {
    ec.mu.Lock()
    defer ec.mu.Unlock()
    return ec.events
}
```

Usage:
```go
func TestWithCapture(t *testing.T) {
    capture := testutil.NewEventCapture[Order](3)

    c.Hook(signal, capture.Handler(orderKey))

    // ... emit events ...

    capture.Wait(t, time.Second)

    events := capture.Events()
    if len(events) != 3 {
        t.Errorf("Expected 3 events, got %d", len(events))
    }
}
```

## Best Practices

### 1. Use Sync Mode for Tests

```go
c := capitan.New(capitan.WithSyncMode())
```

Sync mode processes events synchronously, making tests deterministic.

### 2. Always Set Timeouts

```go
select {
case <-done:
case <-time.After(time.Second):
    t.Fatal("Timeout")
}
```

### 3. Clean Up Resources

```go
defer func() {
    sub.Close()
    pub.Close()
    c.Shutdown()
}()
```

### 4. Isolate Tests

Use separate capitan instances per test to avoid cross-test pollution.

### 5. Test Error Paths

```go
func TestSubscriber_ProviderError(t *testing.T) {
    provider := newMockProvider()
    provider.SendError(errors.New("connection lost"))
    // ... verify graceful handling ...
}
```

## Next Steps

- [Providers Guide](./2.providers.md) - All 12 providers
- [Pipeline Options](./3.pipeline-options.md) - Testing middleware
- [Error Handling Cookbook](../4.cookbook/3.error-handling.md) - Error scenarios
